<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Low-latency Error Augmentation Framework for C++11">
<title>LEAF</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/

/* Zajo's custom font import. The rest of the customizations are at the bottom of this css file,  which is otherwise kept unchanged */
@import "https://fonts.googleapis.com/css?family=Anonymous+Pro|Istok+Web|Quicksand|Poiret+One";

article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}

/* Zajo's customizations applied on top of the standard asciidoctor css above */
h1{font-size:4em}
h2{font-size:1.74em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.5em}
h4{font-size:1.2em}
h5{font-size:1em}
h6{font-size:1em}
h1 code{color:#4101a7; font-size:113%}
h2 code{color:#4101a7; font-size:113%}
h3 code{color:#4101a7; font-size:113%}
h4 code{color:#4101a7; font-size:113%}
h5 code{color:#4101a7; font-size:113%}
#toc {text-align:left}
#toc ul code{font-size:111%}
#toc a:hover code {color:#4101a7}
a:focus{outline:0}
body{text-align:left; background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Istok Web","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#a0a0a0;font-weight:400;margin-top:0;margin-bottom:.25em}
a{color:#000000;text-decoration:underline;line-height:inherit}
a:hover{color:#4101a7}
a:focus{color:#000000}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Quicksand","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#4101a7;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
code{font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
*:not(pre)>code{font-size:1.09em;font-style:normal!important;letter-spacing:0;padding:0 0;word-spacing:-.15em;background-color:transparent;-webkit-border-radius:0;border-radius:0;line-height:1.45;text-rendering:optimizeLegibility;word-wrap:break-word}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeLegibility;font-size:1.05em}
kbd{font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
#header>h1:first-child{font-family:"Poiret One";color:#ff5100;margin-top:2.25rem;margin-bottom:0;letter-spacing:-.07em}
#toc ul{font-family:"Quicksand","DejaVu Sans",sans-serif;list-style-type:none}
#toc a:hover{color:#4101a7}
#toc.toc2{background-color:#f7f8f7}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#606060}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";color:#606060;text-shadow:none}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#ff5100}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#ff5100}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#ff5100}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:#606060;-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.exampleblock>.content{background-color:#ffffff;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.quoteblock blockquote::before{margin-left:-.8em;color:#4101a7}
.quoteblock blockquote{font-family:"Istok Web","DejaVu Serif"; font-size:1.0625rem; padding:0.5em}

/*
Barlow Semi Condensed
Biryani
Cambay
Carme
Gill Sans
Gothic A1
Gudea
JejuGothic
Mplus 1p
OxygenProza Libre
Roboto
Scada
Signika
Ubuntu
Work Sans
Yantramanav

Doppio One
K2D
Martel Sans
Tauri
*/

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>LEAF</h1>
<div class="details">
<span id="author" class="author">Low-latency Error Augmentation Framework for C++11</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#introduction">Five Minute Introduction</a>
<ul class="sectlevel2">
<li><a href="#introduction-result">Using Error Codes</a></li>
<li><a href="#introduction-eh">Using Exception Handling</a></li>
</ul>
</li>
<li><a href="#synopsis">Synopsis</a>
<ul class="sectlevel2">
<li><a href="#_reporting_errors">Reporting Errors</a>
<ul class="sectlevel3">
<li><a href="#_error_hpp"><code>error.hpp</code></a></li>
<li><a href="#_common_hpp"><code>common.hpp</code></a></li>
<li><a href="#_result_hpp"><code>result.hpp</code></a></li>
<li><a href="#_throw_hpp"><code>throw.hpp</code></a></li>
<li><a href="#_exception_to_result_hpp"><code>exception_to_result.hpp</code></a></li>
<li><a href="#_preload_hpp"><code>preload.hpp</code></a></li>
</ul>
</li>
<li><a href="#_error_handling">Error Handling</a>
<ul class="sectlevel3">
<li><a href="#_handle_hpp"><code>handle.hpp</code></a></li>
<li><a href="#_try_hpp"><code>try.hpp</code></a></li>
</ul>
</li>
<li><a href="#_multi_thread_programming">Multi-Thread Programming</a>
<ul class="sectlevel3">
<li><a href="#_capture_result_hpp"><code>capture_result.hpp</code></a></li>
<li><a href="#_capture_exception_hpp"><code>capture_exception.hpp</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Common API</a>
<ul class="sectlevel2">
<li><a href="#e_objects">E-Objects</a>
<ul class="sectlevel3">
<li><a href="#is_error_type"><code>is_error_type</code></a></li>
<li><a href="#propagation">Propagation</a></li>
<li><a href="#diagnostic_information">Diagnostic Information</a></li>
<li><a href="#e_api_function"><code>e_api_function</code></a></li>
<li><a href="#e_file_name"><code>e_file_name</code></a></li>
<li><a href="#e_errno"><code>e_errno</code></a></li>
<li><a href="#e_LastError"><code>e_LastError</code></a></li>
<li><a href="#e_at_line"><code>e_at_line</code></a></li>
<li><a href="#e_type_info_name"><code>e_type_info_name</code></a></li>
<li><a href="#e_source_location"><code>e_source_location</code></a></li>
</ul>
</li>
<li><a href="#error_id"><code>error_id</code></a>
<ul class="sectlevel3">
<li><a href="#new_error"><code>new_error</code></a></li>
<li><a href="#next_error"><code>next_error</code></a></li>
<li><a href="#last_error"><code>last_error</code></a></li>
<li><a href="#propagate"><code>propagate</code></a></li>
<li><a href="#operator_eq-error_id"><code>operator==</code></a></li>
<li><a href="#operator_neq-error_id"><code>operator!=</code></a></li>
<li><a href="#operator_shl-error_id"><code>operator&lt;&lt;</code></a></li>
</ul>
</li>
<li><a href="#preload"><code>preload</code></a></li>
<li><a href="#defer"><code>defer</code></a></li>
<li><a href="#error_info"><code>error_info</code></a></li>
<li><a href="#diagnostic_info"><code>diagnostic_info</code></a></li>
<li><a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a></li>
</ul>
</li>
<li><a href="#_noexcept_api">Noexcept API</a>
<ul class="sectlevel2">
<li><a href="#result"><code>result</code></a>
<ul class="sectlevel3">
<li><a href="#result::result">Constructors</a></li>
<li><a href="#result::operator_eq"><code>operator=</code></a></li>
<li><a href="#result::operator_bool">Conversion to <code>bool</code></a></li>
<li><a href="#result::value"><code>value</code>/<code>operator*</code></a></li>
<li><a href="#result::error"><code>error</code></a></li>
<li><a href="#bad_result"><code>bad_result</code></a></li>
</ul>
</li>
<li><a href="#handle_some"><code>handle_some</code></a></li>
<li><a href="#handle_all"><code>handle_all</code></a></li>
<li><a href="#match"><code>match</code></a></li>
<li><a href="#capture_result"><code>capture_result</code></a></li>
<li><a href="#LEAF_ERROR"><code>LEAF_ERROR</code></a></li>
<li><a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a></li>
<li><a href="#LEAF_CHECK"><code>LEAF_CHECK</code></a></li>
</ul>
</li>
<li><a href="#_exception_handling_api">Exception Handling API</a>
<ul class="sectlevel2">
<li><a href="#exception"><code>exception</code></a></li>
<li><a href="#try_"><code>try_</code></a></li>
<li><a href="#catch_"><code>catch_</code></a></li>
<li><a href="#get_error_id"><code>get_error_id</code></a></li>
<li><a href="#exception_to_result"><code>exception_to_result</code></a></li>
<li><a href="#capture_exception"><code>capture_exception</code></a></li>
<li><a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a></li>
<li><a href="#LEAF_THROW"><code>LEAF_THROW</code></a></li>
</ul>
</li>
<li><a href="#techniques">Programming Techniques</a>
<ul class="sectlevel2">
<li><a href="#technique_preload">Preloading Error Objects</a></li>
<li><a href="#technique_defer">Capturing <code>errno</code> with <code>defer</code></a></li>
<li><a href="#technique_augment_in_catch">Augmenting Exceptions in a <code>catch</code></a></li>
<li><a href="#technique_disparate_error_types">Working with Disparate Error Types</a></li>
<li><a href="#technique_exception_to_result">Converting Exceptions to <code>result&lt;T&gt;</code></a></li>
<li><a href="#technique_preload_in_c_callbacks">Using <code>next_error</code> in (Lua) C-callbacks</a></li>
<li><a href="#technique_transport">Transporting Error Objects Between Threads</a>
<ul class="sectlevel3">
<li><a href="#technique_transport-result">Using <code>result&lt;T&gt;</code></a></li>
<li><a href="#technique_transport-exceptions">Using Exception Handling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#rationale">Design</a>
<ul class="sectlevel2">
<li><a href="#_rationale">Rationale</a></li>
<li><a href="#exception_specifications">Critique 1: LEAF Does Not Enforce Correct Error Handling at Compile Time</a></li>
<li><a href="#translation">Critique 2: LEAF Does Not Facilitate Mapping Between Disparate Error Codes</a></li>
</ul>
</li>
<li><a href="#_alternatives_to_leaf">Alternatives to LEAF</a>
<ul class="sectlevel2">
<li><a href="#boost_exception">Comparison to Boost Exception</a></li>
<li><a href="#boost_outcome">Comparison to Boost Outcome</a>
<ul class="sectlevel3">
<li><a href="#_design_differences">Design Differences</a></li>
<li><a href="#_the_interoperability_problem">The Interoperability Problem</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#distribution">Distribution</a></li>
<li><a href="#portability">Portability</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#_acknowledgements">Acknowledgements</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF is a C&#43;&#43;11 error handling library. Features:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Header-only, no dependencies.</p>
</li>
<li>
<p>No dynamic memory allocations.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p>Any error-related object of any movable type is efficiently delivered to the correct error handler.</p>
</li>
<li>
<p>Compatible with <code>std::error_code</code>, <code>errno</code> and any other error code type.</p>
</li>
<li>
<p>Support for multi-thread programming.</p>
</li>
<li>
<p>Can be used with or without exception handling.</p>
</li>
</ul>
</div>
<div class="paragraph text-right">
<p><a href="https://github.com/zajo/leaf">GitHub</a> | <a href="#introduction">Introduction</a> | <a href="#techniques">Programming Techniques</a> | <a href="#rationale">Design Rationale</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">Five Minute Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ll write a short but complete program that reads a text file in a buffer and prints it to <code>std::cout</code>, using LEAF to handle errors. For demonstration, we&#8217;ll implement two versions: one using error codes, and one using exception handling.</p>
</div>
<div class="sect2">
<h3 id="introduction-result">Using Error Codes</h3>
<div class="paragraph">
<p>First, we need an <code>enum</code> to define our error codes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">enum</span> error_code
{
  bad_command_line = <span class="integer">1</span>,
  input_file_open_error,
  input_file_size_error,
  input_file_read_error,
  input_eof_error,
  cout_error
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Very nice, but how does LEAF know that this <code>enum</code> represents error codes and not, say, types of cold cuts sold at <a href="http://order.bcdeli.com/">Bay Cities Italian Deli</a>? It doesn&#8217;t, unless we tell it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> is_error_type&lt;error_code&gt;: std::true_type { };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, reading and printing a file may not seem like a complex job, but let&#8217;s split it into several functions, each communicating failures using <code>leaf::result&lt;T&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="comment">//Parse the command line, return the file name.</span>
leaf::result&lt;<span class="predefined-type">char</span> <span class="directive">const</span> *&gt; parse_command_line( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] );

<span class="comment">//Open a file for reading.</span>
leaf::result&lt;std::shared_ptr&lt;FILE&gt;&gt; file_open( <span class="predefined-type">char</span> <span class="directive">const</span> * file_name );

<span class="comment">//Return the size of the file.</span>
leaf::result&lt;<span class="predefined-type">int</span>&gt; file_size( FILE &amp; f );

<span class="comment">//Read size bytes from f into buf.</span>
leaf::result&lt;<span class="directive">void</span>&gt; file_read( FILE &amp; f, <span class="directive">void</span> * buf, <span class="predefined-type">int</span> size );</code></pre>
</div>
</div>
<div class="paragraph">
<p>What&#8217;s this <code>result&lt;T&gt;</code> template, you ask? It&#8217;s a simple variant: it holds a value of type <code>T</code> or else it represents an error condition. This way, functions can communicate failures&#8201;&#8212;&#8201;and we don&#8217;t even need an error code to represent success. Which makes sense if you think about it.</p>
</div>
<div class="paragraph">
<p>Now on to the <code>main</code> function: it will call functions as needed and handle all the errors that occur. Did I say <strong>all</strong> the errors? I did, so we&#8217;ll use <code>leaf::handle_all</code>. It has the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">TryBlock</span>, <span class="keyword">class</span><span class="error">.</span>.. Handler&gt;
&lt;&lt;deduced-type&gt;&gt; handle_all( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TryBlock</code> is a function type, almost always a lambda, which is required to return an instance of the <code>result</code> template. The first thing <code>handle_all</code> does is invoke the <code>try_block</code>. If the returned object indicates success, <code>handle_all</code> returns the contained value; otherwise it calls a suitable error handling function from the <code>handler&#8230;&#8203;</code> list.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s see just what kind of a <code>TryBlock</code> will our <code>main</code> function pass to <code>handle_all</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] )
{
  <span class="keyword">return</span> leaf::handle_all(

    [&amp;]() -&gt; leaf::result&lt;<span class="predefined-type">int</span>&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    {
      leaf::result&lt;<span class="predefined-type">char</span> <span class="directive">const</span> *&gt; file_name = parse_command_line(argc,argv);
      <span class="keyword">if</span>( !file_name )
        <span class="keyword">return</span> file_name.error(); <i class="conum" data-value="2"></i><b>(2)</b>

      <span class="directive">auto</span> propagate = leaf::preload( leaf::e_file_name{*file_name} ); <i class="conum" data-value="3"></i><b>(3)</b>

      leaf::result&lt;std::shared_ptr&lt;FILE&gt;&gt; f = file_open(*file_name);
      <span class="keyword">if</span>( !f )
        <span class="keyword">return</span> f.error(); <i class="conum" data-value="4"></i><b>(4)</b>

      leaf::result&lt;<span class="predefined-type">int</span>&gt; s = file_size(**f);
      <span class="keyword">if</span>( !s )
        <span class="keyword">return</span> s.error(); <i class="conum" data-value="4"></i><b>(4)</b>

      std::<span class="predefined-type">string</span> buffer( <span class="integer">1</span> + *s, <span class="char">'\0'</span> );
      leaf::result&lt;<span class="directive">void</span>&gt; fr = file_read(**f, &amp;buffer[<span class="integer">0</span>], buffer.size()-<span class="integer">1</span>);
      <span class="keyword">if</span>( !fr )
        <span class="keyword">return</span> fr.error(); <i class="conum" data-value="4"></i><b>(4)</b>

      std::cout &lt;&lt; buffer;
      std::cout.flush();
      <span class="keyword">if</span>( std::cout.fail() )
        <span class="keyword">return</span> leaf::new_error( cout_error, leaf::e_errno{errno} ); <i class="conum" data-value="5"></i><b>(5)</b>

      <span class="keyword">return</span> <span class="integer">0</span>;
    },

    .... <i class="conum" data-value="6"></i><b>(6)</b>

  ); <i class="conum" data-value="7"></i><b>(7)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Our <code>TryBlock</code> returns a <code>result&lt;int&gt;</code>. In case of success, it will hold <code>0</code>, which will be returned from <code>main</code> to the OS.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If <code>parse_command_line</code> returns an error, we return that error to <code>handle_all</code> (which invoked us). Otherwise, the returned <code>file_name</code> stores a value of type <code>char const *</code>, which we can access by "dereferencing" it: <code>*file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>From now on, all errors escaping this scope will automatically communicate the (now successfully parsed from the command line) file name (LEAF defines <code>struct e_file_name {std::string value;}</code>). It&#8217;s as if every time one of the following functions reports an error, <code>preload</code> says "wait, put this <code>e_file_name</code> thing with the error, it&#8217;s important!"</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Call more functions, forward each failure to the caller&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203;but this is slightly different: we didn&#8217;t get a failure via <code>result&lt;T&gt;</code> from another function, this is our own error we&#8217;ve detected! We return a <code>new_error</code>, passing the <code>cout_error</code> error code and the system <code>errno</code> (LEAF defines <code>struct e_errno {int value;}</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>List of error handlers goes here. We&#8217;ll see that later.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This concludes the <code>handle_all</code> arguments&#8201;&#8212;&#8201;as well as our program!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nice and simple! Writing the <code>TryBlock</code>, we concentrate on the "no errors" code path&#8201;&#8212;&#8201;if we encounter any error we just return it to <code>handle_all</code> for processing. Well, that&#8217;s if we&#8217;re being good and using RAII for automatic clean-up&#8201;&#8212;&#8201;which we are, <code>shared_ptr</code> will automatically close the file for us.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at the juicy second part of the call to <code>handle_all</code>, which lists our error handlers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] )
{
  <span class="keyword">return</span> leaf::handle_all(

    [&amp;]() -&gt; leaf::result&lt;<span class="predefined-type">int</span>&gt;
    {
      .... <i class="conum" data-value="1"></i><b>(1)</b>
    },

    [ ](leaf::match&lt;error_code, input_file_open_error&gt;, <i class="conum" data-value="2"></i><b>(2)</b>
        leaf::match&lt;leaf::e_errno, ENOENT&gt;,
        leaf::e_file_name <span class="directive">const</span> &amp; fn)
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File not found: </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn.value &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">1</span>;
    },

    [ ](leaf::match&lt;error_code, input_file_open_error&gt;, <i class="conum" data-value="3"></i><b>(3)</b>
        leaf::e_errno <span class="directive">const</span> &amp; errn,
        leaf::e_file_name <span class="directive">const</span> &amp; fn)
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to open </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">2</span>;
    },

    [ ](leaf::match&lt;error_code, input_file_size_error, input_file_read_error, input_eof_error&gt;, <i class="conum" data-value="4"></i><b>(4)</b>
        leaf::e_errno <span class="directive">const</span> &amp; errn,
        leaf::e_file_name <span class="directive">const</span> &amp; fn)
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to access </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">3</span>;
    },

    [ ](leaf::match&lt;error_code, cout_error&gt;, <i class="conum" data-value="5"></i><b>(5)</b>
        leaf::e_errno <span class="directive">const</span> &amp; errn)
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Output error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">4</span>;
    },

    [ ](leaf::match&lt;error_code, bad_command_line&gt;) <i class="conum" data-value="6"></i><b>(6)</b>
    {
      std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad command line argument</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">5</span>;
    },

    [ ](leaf::error_info <span class="directive">const</span> &amp; unmatched) <i class="conum" data-value="7"></i><b>(7)</b>
    {
      std::cerr &lt;&lt;
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown failure detected</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl &lt;&lt;
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Cryptic diagnostic information follows</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl &lt;&lt;
        unmatched;
      <span class="keyword">return</span> <span class="integer">6</span>;
    }
  );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the <code>TryBlock</code> from the previous listing, it does all the work and bails out if it encounters an error. In that case, <code>handle_all</code> will consider the error handlers that follow, in order, and it will call the first one that can deal with the error:</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This handler will be called if the error includes:<br>
• an object of type <code>error_code</code> equal to <code>input_file_open_error</code>, and<br>
• an object of type <code>leaf::e_errno</code> that has <code>.value</code> equal to <code>ENOENT</code>, and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This handler will be called if the error includes:<br>
• an object of type <code>error_code</code> equal to <code>input_file_open_error</code>, and<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>), and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This handler will be called if the error includes:<br>
• an object of type <code>error_code</code> equal to any of <code>input_file_size_error</code>, <code>input_file_read_error</code>, <code>input_eof_error</code>, and<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>), and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This handler will be called if the error includes:<br>
• an object of type <code>error_code</code> equal to <code>cout_error</code>, and<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>),</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This handler will be called if the error includes an object of type <code>error_code</code> equal to <code>bad_command_line</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This last handler matches any error: it prints diagnostic information to help debug logic errors in the program, since it failed to match  an appropriate error handler to the error condition it encountered. In this program this handler will never be called, but it is required by <code>handle_all</code> because, well, it must handle all errors (the alternative is to use <code>handle_some</code> instead, which doesn&#8217;t require a "catch all" last-resort handler; instead, if it fails to find a suitable handler for an error, it returns the error to its caller).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To conclude this introduction, let&#8217;s look at one of the error-reporting functions that our <code>TryBlock</code> calls, for example <code>file_open</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;std::shared_ptr&lt;FILE&gt;&gt; file_open( <span class="predefined-type">char</span> <span class="directive">const</span> * file_name )
{
  <span class="keyword">if</span>( FILE * f = fopen(file_name,<span class="string"><span class="delimiter">&quot;</span><span class="content">rb</span><span class="delimiter">&quot;</span></span>) )
    <span class="keyword">return</span> std::shared_ptr&lt;FILE&gt;(f,&amp;fclose);
  <span class="keyword">else</span>
    <span class="keyword">return</span> leaf::new_error( input_file_open_error, leaf::e_errno{errno} );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>fopen</code> succeeds, we return a <code>shared_ptr</code> which will automatically call <code>fclose</code> as needed. If <code>fopen</code> fails, we report an error by calling <code>new_error</code>, which takes any number of error objects to send with the error. In this case we pass the error code (<code>input_file_open_error</code>), as well as the system <code>errno</code> (LEAF defines <code>struct e_errno {int value;}</code>).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The complete program from this tutorial is available <a href="https://github.com/zajo/leaf/blob/master/example/print_file_result.cpp?ts=3">here</a>. The <a href="https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp?ts=3">other</a> version of the same program uses exception handling to report errors (see <a href="#introduction-eh">below</a>).
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="introduction-eh">Using Exception Handling</h3>
<div class="paragraph">
<p>And now, we&#8217;ll write the same program that reads a text file in a buffer and prints it to <code>std::cout</code>, this time using exceptions to report errors.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When used with exception handling, LEAF can be viewed as <a href="#boost_exception">a better Boost Exception</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>First, we need to define our exception class hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> print_file_error : <span class="directive">virtual</span> std::exception { };
<span class="keyword">struct</span> command_line_error : <span class="directive">virtual</span> print_file_error { };
<span class="keyword">struct</span> bad_command_line : <span class="directive">virtual</span> command_line_error { };
<span class="keyword">struct</span> input_error : <span class="directive">virtual</span> print_file_error { };
<span class="keyword">struct</span> input_file_error : <span class="directive">virtual</span> input_error { };
<span class="keyword">struct</span> input_file_open_error : <span class="directive">virtual</span> input_file_error { };
<span class="keyword">struct</span> input_file_size_error : <span class="directive">virtual</span> input_file_error { };
<span class="keyword">struct</span> input_file_read_error : <span class="directive">virtual</span> input_file_error { };
<span class="keyword">struct</span> input_eof_error : <span class="directive">virtual</span> input_file_error { };</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To avoid ambiguities in the dynamic type conversion which occur when catching a base type, it is generally recommended to use virtual inheritance in exception type hierarchies.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We&#8217;ll split the job into several functions, each communicating failures by throwing exceptions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="comment">//Parse the command line, return the file name.</span>
<span class="predefined-type">char</span> <span class="directive">const</span> * parse_command_line( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] );

<span class="comment">//Open a file for reading.</span>
std::shared_ptr&lt;FILE&gt; file_open( <span class="predefined-type">char</span> <span class="directive">const</span> * file_name );

<span class="comment">//Return the size of the file.</span>
<span class="predefined-type">int</span> file_size( FILE &amp; f );

<span class="comment">//Read size bytes from f into buf.</span>
<span class="directive">void</span> file_read( FILE &amp; f, <span class="directive">void</span> * buf, <span class="predefined-type">int</span> size );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>main</code> function brings everything together and handles all the exceptions that are thrown, but instead of using <code>try</code>, it will use the function template <code>leaf::try_</code>, which has the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">TryBlock</span>, <span class="keyword">class</span><span class="error">.</span>.. Handler&gt;
&lt;&lt;deduced-type&gt;&gt; try_( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TryBlock</code> is a function type, almost always a lambda; <code>try_</code> simply returns the value returned by the <code>try_block</code>, catching any exception it throws, in which case <code>try_</code> calls a suitable error handling function from the <code>handler&#8230;&#8203;</code> list.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the <code>TryBlock</code> our <code>main</code> function passes to <code>try_</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] )
{
  std::cout.exceptions(std::ostream::failbit | std::ostream::badbit); <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">return</span> leaf::try_(

    [&amp;] <i class="conum" data-value="2"></i><b>(2)</b>
    {
      <span class="predefined-type">char</span> <span class="directive">const</span> * file_name = parse_command_line(argc,argv); <i class="conum" data-value="3"></i><b>(3)</b>

      <span class="directive">auto</span> propagate = leaf::preload( leaf::e_file_name{file_name} ); <i class="conum" data-value="4"></i><b>(4)</b>

      std::shared_ptr&lt;FILE&gt; f = file_open( file_name );

      std::<span class="predefined-type">string</span> buffer( <span class="integer">1</span>+file_size(*f), <span class="char">'\0'</span> );
      file_read(*f,&amp;buffer[<span class="integer">0</span>],buffer.size()-<span class="integer">1</span>);

      <span class="directive">auto</span> propagate2 = leaf::defer([ ] { <span class="keyword">return</span> leaf::e_errno{errno}; } ); <i class="conum" data-value="5"></i><b>(5)</b>
      std::cout &lt;&lt; buffer;
      std::cout.flush();

      <span class="keyword">return</span> <span class="integer">0</span>;
    },

    .... <i class="conum" data-value="6"></i><b>(6)</b>

  ); <i class="conum" data-value="7"></i><b>(7)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure <code>std::cout</code> to throw on error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Except if it throws, our <code>TryBlock</code> returns <code>0</code>, which will be returned from <code>main</code> to the OS.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If any of the functions we call throws, <code>try_</code> will find an appropriate handler to invoke. We&#8217;ll look at that later.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>From now on, all exceptions escaping this scope will automatically communicate the (now successfully parsed from the command line) file name (LEAF defines <code>struct e_file_name {std::string value;}</code>). It&#8217;s as if every time one of the following functions throws an exception, <code>preload</code> says "wait, put this <code>e_file_name</code> thing with the exception, it&#8217;s important!"</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>defer</code> is similar to <code>preload</code>, but instead of the error object, it takes a function that returns it. From this point on, when an exception escapes this scope, <code>defer</code> will call the passed function and include the returned <code>e_errno</code> with the exception (LEAF defines <code>struct e_errno {int value;}</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>List of error handlers goes here. We&#8217;ll see that later.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This concludes the <code>try_</code> arguments&#8201;&#8212;&#8201;as well as our program!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As it is always the case when using exception handling, as long as our <code>TryBlock</code> is exception-safe, we can concentrate on the "no errors" code path. Of course, our <code>TryBlock</code> is exception-safe, since <code>shared_ptr</code> will automatically close the file for us in case an exception is thrown.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at the second part of the call to <code>try_</code>, which lists the error handlers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] )
{
  std::cout.exceptions(std::ostream::failbit | std::ostream::badbit); <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">return</span> leaf::try_(
    [&amp;]
    {
      .... <i class="conum" data-value="2"></i><b>(2)</b>
    },

    [ ](leaf::catch_&lt;input_file_open_error&gt;, <i class="conum" data-value="3"></i><b>(3)</b>
        leaf::match&lt;leaf::e_errno,ENOENT&gt;,
        leaf::e_file_name <span class="directive">const</span> &amp; fn)
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File not found: </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn.value &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">1</span>;
    },

    [ ](leaf::catch_&lt;input_file_open_error&gt;, <i class="conum" data-value="4"></i><b>(4)</b>
        leaf::e_errno <span class="directive">const</span> &amp; errn,
        leaf::e_file_name <span class="directive">const</span> &amp; fn )
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to open </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">2</span>;
    },

    [ ](leaf::catch_&lt;input_error&gt;, <i class="conum" data-value="5"></i><b>(5)</b>
        leaf::e_errno <span class="directive">const</span> &amp; errn,
        leaf::e_file_name <span class="directive">const</span> &amp; fn )
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to access </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">3</span>;
    },

    [ ](leaf::catch_&lt;std::ostream::failure&gt;, <i class="conum" data-value="6"></i><b>(6)</b>
        leaf::e_errno <span class="directive">const</span> &amp; errn )
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Output error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">4</span>;
    },

    [ ](leaf::catch_&lt;bad_command_line&gt;) <i class="conum" data-value="7"></i><b>(7)</b>
    {
      std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad command line argument</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
      <span class="keyword">return</span> <span class="integer">5</span>;
    },

    [ ](leaf::error_info <span class="directive">const</span> &amp; unmatched) <i class="conum" data-value="8"></i><b>(8)</b>
    {
      std::cerr &lt;&lt;
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown failure detected</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl &lt;&lt;
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Cryptic diagnostic information follows</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl &lt;&lt;
        unmatched;
      <span class="keyword">return</span> <span class="integer">6</span>;
    } );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure <code>std::cout</code> to throw on error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the <code>TryBlock</code> from the previous listing; if it throws, <code>try_</code> will catch the exception, then consider the error handlers that follow, in order, and it will call the first one that can deal with the error:</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This handler will be called if:<br>
• an <code>input_file_open_error</code> exception was caught, with<br>
• an object of type <code>leaf::e_errno</code> that has <code>.value</code> equal to <code>ENOENT</code>, and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This handler will be called if:<br>
• an <code>input_file_open_error</code> exception was caught, with<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>), and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This handler will be called if:<br>
• an <code>input_error</code> exception was caught (which is a base type), with<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>), and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This handler will be called if:<br>
• an <code>std::ostream::failure</code> exception was caught, with<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>),</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This handler will be called if a <code>bad_command_line</code> exception was caught.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>If <code>try_</code> fails to find an appropriate handler, it will re-throw the exception. But this is the <code>main</code> function which should handle all exceptions, so this last handler matches any error and prints diagnostic information, to help debug logic errors.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To conclude this introduction, let&#8217;s look at one of the error-reporting functions that our <code>TryBlock</code> calls, for example <code>file_open</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">std::shared_ptr&lt;FILE&gt; file_open( <span class="predefined-type">char</span> <span class="directive">const</span> * file_name )
{
  <span class="keyword">if</span>( FILE * f = fopen(file_name,<span class="string"><span class="delimiter">&quot;</span><span class="content">rb</span><span class="delimiter">&quot;</span></span>) )
    <span class="keyword">return</span> std::shared_ptr&lt;FILE&gt;(f,&amp;fclose);
  <span class="keyword">else</span>
    <span class="keyword">throw</span> leaf::exception( input_file_open_error(), leaf::e_errno{errno} );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>fopen</code> succeeds, it returns a <code>shared_ptr</code> which will automatically call <code>fclose</code> as needed. If <code>fopen</code> fails, we throw the exception object returned by <code>leaf::exception</code>, which takes as its first argument an exception object, followed by any number of error objects to send with it. In this case we pass the system <code>errno</code> (LEAF defines <code>struct e_errno {int value;}</code>). The returned object can be caught as <code>input_file_open_error</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>try_</code> can work with any exception, not only exceptions thrown using <code>leaf::exception</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The complete program from this tutorial is available <a href="https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp?ts=3">here</a>. The <a href="https://github.com/zajo/leaf/blob/master/example/print_file_result.cpp?ts=3">other</a> version of the same program does not use exception handling to report errors (see the <a href="#introduction-result">previous introduction</a>).
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="synopsis">Synopsis</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_reporting_errors">Reporting Errors</h3>
<div class="sect3">
<h4 id="_error_hpp"><code>error.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">class</span> <span class="class">error_id</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  error_id new_error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

  error_id next_error() <span class="directive">noexcept</span>;

  error_id last_error() <span class="directive">noexcept</span>;

  <span class="keyword">class</span> <span class="class">error_id</span>
  {
  <span class="directive">public</span>:

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    error_id propagate( E &amp;&amp; ... e ) <span class="directive">const</span> <span class="directive">noexcept</span>;

    <span class="directive">friend</span> <span class="predefined-type">bool</span> <span class="directive">operator</span>==( error_id <span class="directive">const</span> &amp; e1, error_id <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;
    <span class="directive">friend</span> <span class="predefined-type">bool</span> <span class="directive">operator</span>!=( error_id <span class="directive">const</span> &amp; e1, error_id <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;

    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, error_id <span class="directive">const</span> &amp; e )
  };

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="keyword">struct</span> is_error_type
  {
    <span class="directive">static</span> <span class="directive">constexpr</span> <span class="predefined-type">bool</span> value = &lt;&lt;unspecified&gt;&gt;;
  };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_id"><code>error_id</code></a> | <a href="#new_error"><code>new_error</code></a> | <a href="#next_error"><code>next_error</code></a> | <a href="#last_error"><code>last_error</code></a> | <a href="#propagate"><code>propagate</code></a> | <a href="#operator_eq-error_id"><code>operator==</code></a> | <a href="#operator_neq-error_id"><code>operator!=</code></a> | <a href="#operator_shl-error_id"><code>operator&lt;&lt;</code></a> | <a href="#is_error_type"><code>is_error_type</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_common_hpp"><code>common.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> e_api_function    { .... };
  <span class="keyword">struct</span> e_file_name       { .... };
  <span class="keyword">struct</span> e_errno           { .... };
  <span class="keyword">struct</span> e_at_line         { .... };
  <span class="keyword">struct</span> e_type_info_name  { .... };
  <span class="keyword">struct</span> e_source_location { .... };

  <span class="keyword">namespace</span> windows
  {
    <span class="keyword">struct</span> e_LastError  { .... };
  }

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#e_api_function"><code>e_api_function</code></a> | <a href="#e_file_name"><code>e_file_name</code></a> | <a href="#e_errno"><code>e_errno</code></a> | <a href="#e_LastError"><code>e_LastError</code></a> | <a href="#e_at_line"><code>e_at_line</code></a> | <a href="#e_type_info_name"><code>e_type_info_name</code></a> | <a href="#e_source_location"><code>e_source_location</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_result_hpp"><code>result.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result
  {
  <span class="directive">public</span>:

    result() <span class="directive">noexcept</span>;
    result( T &amp;&amp; v ) <span class="directive">noexcept</span>;
    result( T <span class="directive">const</span> &amp; v );
    result( error_id <span class="directive">const</span> &amp; err ) <span class="directive">noexcept</span>;

    result( result &amp;&amp; r ) <span class="directive">noexcept</span>;
    result( result <span class="directive">const</span> &amp; r );

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
    result( result&lt;U&gt; &amp;&amp; r ) <span class="directive">noexcept</span>

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
    result( result&lt;U&gt; <span class="directive">const</span> &amp; r )

    result &amp; <span class="directive">operator</span>=( result &amp;&amp; r ) <span class="directive">noexcept</span>;
    result &amp; <span class="directive">operator</span>=( result <span class="directive">const</span> &amp; r );

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
    result &amp; <span class="directive">operator</span>=( result&lt;U&gt; &amp;&amp; r ) <span class="directive">noexcept</span>

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
    result &amp; <span class="directive">operator</span>=( result&lt;U&gt; <span class="directive">const</span> &amp; r )

    <span class="directive">explicit</span> <span class="directive">operator</span> <span class="predefined-type">bool</span>() <span class="directive">const</span> <span class="directive">noexcept</span>;

    T <span class="directive">const</span> &amp; value() <span class="directive">const</span>;
    T &amp; value();

    T <span class="directive">const</span> &amp; <span class="directive">operator</span>*() <span class="directive">const</span>;
    T &amp; <span class="directive">operator</span>*();

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    error_id error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;
 };

  <span class="keyword">struct</span> bad_result: std::exception { };

} }

<span class="preprocessor">#define</span> LEAF_ERROR(...) ....
<span class="preprocessor">#define</span> LEAF_AUTO(v,r) ....
<span class="preprocessor">#define</span> LEAF_CHECK(r) ....</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#result::result">Constructors</a> | <a href="#result::operator_eq"><code>operator=</code></a> | <a href="#result::operator_bool">Conversion to <code>bool</code></a> | <a href="#result::value"><code>value</code>/<code>operator*</code></a> | <a href="#result::error"><code>error</code></a> | <a href="#bad_result"><code>bad_result</code></a> | <a href="#LEAF_ERROR"><code>LEAF_ERROR</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a> | <a href="#LEAF_CHECK"><code>LEAF_CHECK</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_throw_hpp"><code>throw.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/throw.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Ex</span>, <span class="keyword">class</span><span class="error">.</span>.. E&gt;
  &lt;&lt;unspecified&gt;&gt; exception( Ex &amp;&amp; ex, E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

} }

<span class="preprocessor">#define</span> LEAF_EXCEPTION(...) ....

<span class="preprocessor">#define</span> LEAF_THROW(...) ....</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#exception"><code>exception</code></a> | <a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a> | <a href="#LEAF_THROW"><code>LEAF_THROW</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_exception_to_result_hpp"><code>exception_to_result.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception_to_result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. Ex, <span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;deduced-type&gt;&gt; exception_to_result( F &amp;&amp; f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#exception_to_result"><code>exception_to_result</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_preload_hpp"><code>preload.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/preload.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  &lt;&lt;unspecified-type&gt;&gt; preload( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. F&gt;
  &lt;&lt;unspecified-type&gt;&gt; defer( F &amp;&amp; ... f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#preload"><code>preload</code></a> | <a href="#defer"><code>defer</code></a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_error_handling">Error Handling</h3>
<div class="sect3">
<h4 id="_handle_hpp"><code>handle.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">TryBlock</span>, <span class="keyword">class</span><span class="error">.</span>.. Handler&gt;
  <span class="keyword">typename</span> std::remove_reference&lt;<span class="directive">decltype</span>(std::declval&lt;TryBlock&gt;()().value())&gt;::type
  handle_all( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">TryBlock</span>, <span class="keyword">class</span><span class="error">.</span>.. Handler&gt;
  <span class="directive">decltype</span>(std::declval&lt;TryBlock&gt;()())
  handle_some( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">E</span>, <span class="keyword">typename</span> deduced-type&lt;E&gt;::type... V&gt;
  <span class="keyword">struct</span> match;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#handle_all"><code>handle_all</code></a> | <a href="#handle_some"><code>handle_some</code></a> | <a href="#match"><code>match</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_try_hpp"><code>try.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/try.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">TryBlock</span>, <span class="keyword">class</span><span class="error">.</span>.. Handler&gt;
  <span class="directive">decltype</span>(std::declval&lt;TryBlock&gt;()()) try_( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">E</span>, <span class="keyword">typename</span> deduced-type&lt;E&gt;::type... V&gt;
  <span class="keyword">struct</span> match;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. Ex&gt;
  <span class="keyword">struct</span> catch_;

  error_id get_error_id( std::exception <span class="directive">const</span> &amp; ex ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_"><code>try_</code></a> | <a href="#match"><code>match</code></a> | <a href="#catch_"><code>catch_</code></a> | <a href="#get_error_id"><code>get_error_id</code></a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_multi_thread_programming">Multi-Thread Programming</h3>
<div class="sect3">
<h4 id="_capture_result_hpp"><code>capture_result.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture_result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E, <span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;unspecified_function_type&gt;&gt; capture_result( F &amp;&amp; f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#capture_result"><code>capture_result</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_capture_exception_hpp"><code>capture_exception.hpp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture_exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E, <span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;unspecified_function_type&gt;&gt; capture_exception( F &amp;&amp; f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#capture_exception"><code>capture_exception</code></a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference">Common API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="e_objects">E-Objects</h3>
<div class="sect3">
<h4 id="is_error_type"><code>is_error_type</code></h4>
<div class="paragraph">
<p>With LEAF, users can efficiently associate with errors or with exceptions any number of values that pertain to a failure. These values may be of any no-throw movable type <code>E</code> for which <code><a href="#is_error_type">is_error_type</a>&lt;E&gt;::value</code> is <code>true</code>. The expectation is that this template will be specialized as needed for e.g. all user-defined error enums.</p>
</div>
<div class="paragraph">
<p>Throughout this text, types for which <code>is_error_type</code> is <code>true</code> are called E-types. Objects of those types are called error objects or E-objects.</p>
</div>
<div class="paragraph">
<p>The main <code>is_error_type</code> template is defined so that <code>is_error_type&lt;E&gt;::value</code> is <code>true</code> when <code>E</code> is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::error_code</code>,</p>
</li>
<li>
<p><code>boost::system::error_code</code>,</p>
</li>
<li>
<p><code>std::exception_ptr</code>,</p>
</li>
<li>
<p>any type <code>E</code> for which <code>std::is_base_of&lt;std::exception, E&gt;::value</code> is <code>true</code>,</p>
</li>
<li>
<p>any type which defines an accessible data member <code>value</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Often, error values that need to be communicated are of generic types (e.g. <code>std::string</code>). Such values should be enclosed in a C-<code>struct</code> that acts as their compile-time identifier and gives them semantic meaning. Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> e_input_name  { std::<span class="predefined-type">string</span> value; };
<span class="keyword">struct</span> e_output_name { std::<span class="predefined-type">string</span> value; };

<span class="keyword">struct</span> e_minimum_temperature { <span class="predefined-type">float</span> value; };
<span class="keyword">struct</span> e_maximum_temperature { <span class="predefined-type">float</span> value; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>By convention, the enclosing C-<code>struct</code> names use the <code>e_</code> prefix.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="propagation">Propagation</h4>
<div class="paragraph">
<p>"To propagate" an E-object is to associate it with a particular <a href="#error_id"><code>error_id</code></a>, making it available to functions that handle that error.</p>
</div>
<div class="paragraph">
<p>More formally, when an E-object is propagated, it is immediately moved to available storage in a <code>handle_some</code>, a <code>handle_all</code> or a <code>try_</code> scope currently active in the calling thread, where it becomes uniquely associated with a specific <a href="#error_id"><code>error_id</code></a>&#8201;&#8212;&#8201;or discarded if storage is not available; see <a href="#handle_some"><code>handle_some</code></a>.</p>
</div>
<div class="paragraph">
<p>Various LEAF functions take a list of E-objects to propagate. As an example, if a function <code>copy_file</code> that takes the name of the input file and the name of the output file as its arguments detects a failure, it could communicate an error code <code>ec</code>, plus the two relevant file names using <a href="#new_error"><code>new_error</code></a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">return</span> leaf::new_error( ec, e_input_name{n1}, e_output_name{n2} );</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="diagnostic_information">Diagnostic Information</h4>
<div class="paragraph">
<p>LEAF is able to automatically generate diagnostic messages that include information about all E-objects available to error handlers. For this purpose, it needs to be able to print objects of user-defined E-types.</p>
</div>
<div class="paragraph">
<p>To do this, LEAF attempts to bind an unqualified call to <code>operator&lt;&lt;</code>, passing a <code>std::ostream</code> and the E-object. If that fails, it will also attempt to bind <code>operator&lt;&lt;</code> that takes the <code>.value</code> of the E-object. If that also doesn&#8217;t compile, the E-object will not appear in diagnostic messages, though LEAF will still print its type.</p>
</div>
<div class="paragraph">
<p>Even with E-types that define a printable <code>.value</code>, the user may still want to overload <code>operator&lt;&lt;</code> for the enclosing <code>struct</code>, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> e_errno
{
  <span class="predefined-type">int</span> value;

  <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, e_errno <span class="directive">const</span> &amp; e )
  {
    <span class="keyword">return</span> os &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">errno = </span><span class="delimiter">&quot;</span></span> &lt;&lt; e.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> &lt;&lt; strerror(e.value) &lt;&lt; <span class="char">'&quot;'</span>;
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>e_errno</code> type above is designed to hold <code>errno</code> values. The defined <code>operator&lt;&lt;</code> overload will automatically include the output from <code>strerror</code> when <code>e_errno</code> values are printed (LEAF defines <code>e_errno</code> in <code>&lt;boost/leaf/common.hpp&gt;</code>, together with other commonly-used error types).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These automatically-generated diagnostic messages are developer-friendly, but not user-friendly. Therefore, <code>operator&lt;&lt;</code> overloads for E-types should only print technical information in English, and should not attempt to localize strings or to format a user-friendly message; this should be done in error-handling functions specifically designed for that purpose.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="e_api_function"><code>e_api_function</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> e_api_function {<span class="predefined-type">char</span> <span class="directive">const</span> * value;};

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>e_api_function</code> type is designed to capture the name of the API function that failed. For example, if you&#8217;re reporting an error from <code>fread</code>, you could use <code>leaf::e_api_function {"fread"}</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The passed value is stored as a C string (<code>char const *</code>), so <code>value</code> should only be initialized with a string literal.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="e_file_name"><code>e_file_name</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> e_file_name {std::<span class="predefined-type">string</span> value;};

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a file operation fails, you could use <code>e_file_name</code> to store the name of the file.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="e_errno"><code>e_errno</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> e_errno
  {
    <span class="predefined-type">int</span> value;
    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, e_errno <span class="directive">const</span> &amp; err );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To capture <code>errno</code>, use <code>e_errno</code>. When printed in automatically-generated diagnostic messages, <code>e_errno</code> objects use <code>strerror</code> to convert the <code>errno</code> code to string.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="e_LastError"><code>e_LastError</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">namespace</span> windows
  {
    <span class="keyword">struct</span> e_LastError
    {
      <span class="predefined-type">unsigned</span> value;
      <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, e_LastError <span class="directive">const</span> &amp; err );
    };
  }

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_LastError</code> is designed to communicate <code>GetLastError()</code> values on Windows.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="e_at_line"><code>e_at_line</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> e_at_line { <span class="predefined-type">int</span> value; };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_at_line</code> can be used to communicate the line number when reporting errors (for example parse errors) about a text file.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="e_type_info_name"><code>e_type_info_name</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> e_type_info_name { <span class="predefined-type">char</span> <span class="directive">const</span> * value; };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_type_info_name</code> is designed to store the return value of <code>std::type_info::name</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="e_source_location"><code>e_source_location</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> e_source_location
  {
    <span class="predefined-type">char</span> <span class="directive">const</span> * <span class="directive">const</span> file;
    <span class="predefined-type">int</span> <span class="directive">const</span> line;
    <span class="predefined-type">char</span> <span class="directive">const</span> * <span class="directive">const</span> function;

    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, e_source_location <span class="directive">const</span> &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="#LEAF_ERROR"><code>LEAF_ERROR</code></a>, <a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a> and <a href="#LEAF_THROW"><code>LEAF_THROW</code></a> macros capture <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code> into a <code>e_source_location</code> object.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="error_id"><code>error_id</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">class</span> <span class="class">error_id</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  error_id new_error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

  error_id next_error() <span class="directive">noexcept</span>;

  error_id last_error() <span class="directive">noexcept</span>;

  <span class="keyword">class</span> <span class="class">error_id</span>
  {
  <span class="directive">public</span>:

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    error_id propagate( E &amp;&amp; ... e ) <span class="directive">const</span> <span class="directive">noexcept</span>;

    <span class="directive">friend</span> <span class="predefined-type">bool</span> <span class="directive">operator</span>==( error_id <span class="directive">const</span> &amp; e1, error_id <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;
    <span class="directive">friend</span> <span class="predefined-type">bool</span> <span class="directive">operator</span>!=( error_id <span class="directive">const</span> &amp; e1, error_id <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;

    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, error_id <span class="directive">const</span> &amp; e )
  };

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="keyword">struct</span> is_error_type
  {
    <span class="directive">static</span> <span class="directive">constexpr</span> <span class="predefined-type">bool</span> value = &lt;&lt;unspecified&gt;&gt;;
  };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_id"><code>error_id</code></a> | <a href="#new_error"><code>new_error</code></a> | <a href="#next_error"><code>next_error</code></a> | <a href="#last_error"><code>last_error</code></a> | <a href="#propagate"><code>propagate</code></a> | <a href="#operator_eq-error_id"><code>operator==</code></a> | <a href="#operator_neq-error_id"><code>operator!=</code></a> | <a href="#operator_shl-error_id"><code>operator&lt;&lt;</code></a> | <a href="#is_error_type"><code>is_error_type</code></a></p>
</div>
<div class="paragraph">
<p>Values of type <code>error_id</code> identify an error across the entire program. They can be copied, moved, assigned to, and compared to other <code>error_id</code> objects. They occupy as much memory, and are as efficient as <code>unsigned int</code>.</p>
</div>
<hr>
<div class="sect3">
<h4 id="new_error"><code>new_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  error_id new_error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code><a href="#is_error_type">is_error_type</a>&lt;E&gt;::value</code> must be <code>true</code> for each <code>E</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each of the <code>e&#8230;&#8203;</code> objects is <a href="#propagation">propagated</a> and uniquely associated with the returned value.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A new <code>error_id</code> value, which is unique across the entire program.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="next_error"><code>next_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  error_id next_error() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The <code>error_id</code> value which will be returned the next time <a href="#new_error"><code>new_error</code></a> is invoked from the calling thread.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This function can be used to associate E-objects with the next <code>error_id</code> value to be reported. Use with caution, only when restricted to reporting errors via specific third-party types, incompatible with LEAF&#8201;&#8212;&#8201;for example when reporting an error from a C callback. As soon as control exits this critical path, you should create a <a href="#new_error"><code>new_error</code></a> (which will be equal to the <code>error_id</code> object returned by the earlier call to <code>next_error</code>).</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="last_error"><code>last_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  error_id last_error() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The <code>error_id</code> value returned the last time <a href="#new_error"><code>new_error</code></a> was invoked from the calling thread.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="propagate"><code>propagate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  error_id error_id::propagate( E &amp;&amp; ... e ) <span class="directive">const</span> <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each of the <code>e&#8230;&#8203;</code> objects is <a href="#propagation">propagated</a> and uniquely associated with <code>*this</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>*this</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="operator_eq-error_id"><code>operator==</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="predefined-type">bool</span> <span class="directive">operator</span>==( error_id <span class="directive">const</span> &amp; e1, error_id <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if the two values <code>e1</code> and <code>e2</code> are equal, <code>false</code> otherwise.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="operator_neq-error_id"><code>operator!=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="predefined-type">bool</span> <span class="directive">operator</span>!=( error_id <span class="directive">const</span> &amp; e1, error_id <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>!(e1==e2)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="operator_shl-error_id"><code>operator&lt;&lt;</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, error_id <span class="directive">const</span> &amp; id )

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Prints an <code>unsigned int</code> value that uniquely identifies the value <code>id</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="preload"><code>preload</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/preload.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  &lt;&lt;unspecified-type&gt;&gt; preload( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code><a href="#is_error_type">is_error_type</a>&lt;E&gt;::value</code> must be <code>true</code> for each <code>E</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>All <code>e&#8230;&#8203;</code> objects are forwarded and stored into the returned object of unspecified type, which should be captured by <code>auto</code> and kept alive in the calling scope. When that object is destroyed:</p>
<div class="ulist">
<ul>
<li>
<p>If <a href="#new_error"><code>new_error</code></a> was invoked (by the calling thread) since the object returned by <code>preload</code> was created, the stored <code>e&#8230;&#8203;</code> objects are <a href="#propagation">propagated</a> and become uniquely associated with  the <em>last</em> such <code>leaf::error_id</code>;</p>
</li>
<li>
<p>Otherwise, if <code>std::unhandled_exception()</code> returns <code>true</code>, the stored <code>e&#8230;&#8203;</code> objects are propagated and will become uniquely associated with the <em>first</em> <code>leaf::error_id</code> created later on;</p>
</li>
<li>
<p>Otherwise, the stored <code>e&#8230;&#8203;</code> objects are discarded.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="defer"><code>defer</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/preload.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. F&gt;
  &lt;&lt;unspecified-type&gt;&gt; defer( F &amp;&amp; ... f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p>Each of <code>f<sub>i</sub></code> in <code>f&#8230;&#8203;</code> must be a function that does not throw exceptions, takes no arguments and returns an object of a no-throw movable type <code>E<sub>i</sub></code> for which <code><a href="#is_error_type">is_error_type</a>&lt;E<sub>i</sub>&gt;::value</code> is <code>true</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>All <code>f&#8230;&#8203;</code> objects are forwarded and stored into the returned object of unspecified type, which should be captured by <code>auto</code> and kept alive in the calling scope. When that object is destroyed:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If <a href="#new_error"><code>new_error</code></a> was invoked (by the calling thread) since the object returned by <code>defer</code> was created, each of the stored <code>f&#8230;&#8203;</code> is called, and each returned object is <a href="#propagation">propagated</a> and becomes uniquely associated with  the <em>last</em> such <code>leaf::error_id</code>;</p>
</li>
<li>
<p>Otherwise, if <code>std::unhandled_exception()</code> returns <code>true</code>, each of the stored <code>f&#8230;&#8203;</code> is called, and each returned object is propagated and will become uniquely associated with the <em>first</em> <code>leaf::error_id</code> created later on;</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>The stored <code>f&#8230;&#8203;</code> objects are discarded.</p>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="error_info"><code>error_info</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">class</span> <span class="class">error_info</span>
  {
    <span class="comment">//Constructors unspecified</span>

  <span class="directive">public</span>:

    leaf::error_id <span class="directive">const</span> &amp; error() <span class="directive">const</span> <span class="directive">noexcept</span>;

    <span class="predefined-type">bool</span> exception_caught() <span class="directive">const</span> <span class="directive">noexcept</span>;

    std::exception <span class="directive">const</span> * exception() <span class="directive">const</span> <span class="directive">noexcept</span>;

    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, error_info <span class="directive">const</span> &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> or <a href="#try_"><code>try_</code></a> may take an argument of type <code>error_info const &amp;</code> to receive information about the error.</p>
</div>
<div class="paragraph">
<p>The <code>error</code> member function returns the program-wide unique <a href="#error_id"><code>error_id</code></a> of the error.</p>
</div>
<div class="paragraph">
<p>The <code>exception_caught</code> member function returns <code>true</code> if the handler that received <code>*this</code> is being invoked by <a href="#try_"><code>try_</code></a>, <code>false</code> if invoked by <a href="#handle_some"><code>handle_some</code></a> or <a href="#handle_all"><code>handle_all</code></a>.</p>
</div>
<div class="paragraph">
<p>The <code>exception</code> member function returns a pointer to the <code>std::exception</code> subobject of the exception caught by <code>try_</code>, or <code>0</code> if that exception could not be converted to <code>std::exception</code>. It is illegal to call <code>exception</code> unless <code>exception_caught()</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The <code>operator&lt;&lt;</code> overload prints diagnostic information about each E-object currently stored in any active <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> or <a href="#try_"><code>try_</code></a> scope, but only if it is associated with the <a href="#error_id"><code>error_id</code></a> returned by <code>error()</code>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="diagnostic_info"><code>diagnostic_info</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">class</span> <span class="class">diagnostic_info</span>
  {
    <span class="comment">//Constructors unspecified</span>

  <span class="directive">public</span>:

    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, diagnostic_info <span class="directive">const</span> &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> or <a href="#try_"><code>try_</code></a> may take an argument of type <code>diagnostic_info const &amp;</code> if they need to print diagnostic information about the error.</p>
</div>
<div class="paragraph">
<p>The message printed by <code>operator&lt;&lt;</code> includes the message printed by <code>error_info</code>, followed by basic information about E-objects that were communicated to LEAF (to be associated with the error) for which there was no storage available in any active <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> or <a href="#try_"><code>try_</code></a> scope (these E-objects were discarded by LEAF, because no handler needed them).</p>
</div>
<div class="paragraph">
<p>The additional information is limited the type name of the first such E-object, as well as their total count.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="verbose_diagnostic_info"><code>verbose_diagnostic_info</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">class</span> <span class="class">verbose_diagnostic_info</span>
  {
    <span class="comment">//Constructors unspecified</span>

  <span class="directive">public</span>:

    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, verbose_diagnostic_info <span class="directive">const</span> &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> or <a href="#try_"><code>try_</code></a> may take an argument of type <code>verbose_diagnostic_info const &amp;</code> if they need to print diagnostic information about the error.</p>
</div>
<div class="paragraph">
<p>The message printed by <code>operator&lt;&lt;</code> includes the message printed by <code>error_info</code>, followed by information about E-objects that were communicated to LEAF (to be associated with the error) for which there was no storage available in any active <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> or <a href="#try_"><code>try_</code></a> scope (these E-objects were discarded by LEAF, because no handler needed them).</p>
</div>
<div class="paragraph">
<p>The additional information includes the types and the values of all such E-objects.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Using <code>verbose_diagnostic_info</code> will likely allocate memory dynamically.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_noexcept_api">Noexcept API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="result"><code>result</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result
  {
  <span class="directive">public</span>:

    result() <span class="directive">noexcept</span>;
    result( T &amp;&amp; v ) <span class="directive">noexcept</span>;
    result( T <span class="directive">const</span> &amp; v );
    result( error_id <span class="directive">const</span> &amp; err ) <span class="directive">noexcept</span>;

    result( result &amp;&amp; r ) <span class="directive">noexcept</span>;
    result( result <span class="directive">const</span> &amp; r );

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
    result( result&lt;U&gt; &amp;&amp; r ) <span class="directive">noexcept</span>

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
    result( result&lt;U&gt; <span class="directive">const</span> &amp; r )

    result &amp; <span class="directive">operator</span>=( result &amp;&amp; r ) <span class="directive">noexcept</span>;
    result &amp; <span class="directive">operator</span>=( result <span class="directive">const</span> &amp; r );

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
    result &amp; <span class="directive">operator</span>=( result&lt;U&gt; &amp;&amp; r ) <span class="directive">noexcept</span>

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
    result &amp; <span class="directive">operator</span>=( result&lt;U&gt; <span class="directive">const</span> &amp; r )

    <span class="directive">explicit</span> <span class="directive">operator</span> <span class="predefined-type">bool</span>() <span class="directive">const</span> <span class="directive">noexcept</span>;

    T <span class="directive">const</span> &amp; value() <span class="directive">const</span>;
    T &amp; value();

    T <span class="directive">const</span> &amp; <span class="directive">operator</span>*() <span class="directive">const</span>;
    T &amp; <span class="directive">operator</span>*();

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    error_id error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;
 };

  <span class="keyword">struct</span> bad_result: std::exception { };

} }

<span class="preprocessor">#define</span> LEAF_ERROR(...) ....
<span class="preprocessor">#define</span> LEAF_AUTO(v,r) ....
<span class="preprocessor">#define</span> LEAF_CHECK(r) ....</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#result::result">Constructors</a> | <a href="#result::operator_eq"><code>operator=</code></a> | <a href="#result::operator_bool">Conversion to <code>bool</code></a> | <a href="#result::value"><code>value</code>/<code>operator*</code></a> | <a href="#result::error"><code>error</code></a> | <a href="#bad_result"><code>bad_result</code></a> | <a href="#LEAF_ERROR"><code>LEAF_ERROR</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a> | <a href="#LEAF_CHECK"><code>LEAF_CHECK</code></a></p>
</div>
<div class="paragraph">
<p>The <code>result&lt;T&gt;</code> type can be returned by functions which produce a value of type <code>T</code> but may fail doing so.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>T</code> must be movable, and its move constructor may not throw.</p>
</dd>
<dt class="hdlist1">Invariant: </dt>
<dd>
<p>A <code>result&lt;T&gt;</code> object is in one of three states:</p>
<div class="ulist">
<ul>
<li>
<p>Value state, in which case it contains an object of type <code>T</code>, and <code><a href="#result::value">value</a></code>/<code><a href="#result::value">operator*</a></code> can be used to access the contained value.</p>
</li>
<li>
<p>Error state, in which case it contains an object of type <a href="#error_id"><code>error_id</code></a>, and calling <code><a href="#result::value">value</a></code>/<code><a href="#result::value">operator*</a></code> throws <code>leaf::<a href="#bad_result">bad_result</a></code>.</p>
</li>
<li>
<p>Error-capture state, which is the same as the Error state, but in addition to the <a href="#error_id"><code>error_id</code></a> object, it holds captured E-objects.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
<div class="sect3">
<h4 id="result::result">Constructors</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt;::result() <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt;::result( T &amp;&amp; v ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt;::result( T <span class="directive">const</span> &amp; v );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt;::result( leaf::error_id <span class="directive">const</span> &amp; err ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt;::result( result &amp;&amp; ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt;::result( result <span class="directive">const</span> &amp; );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
  result&lt;T&gt;::result( result&lt;U&gt; &amp;&amp; ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
  result&lt;T&gt;::result( result&lt;U&gt; <span class="directive">const</span> &amp; );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>T</code> must be movable, and its move constructor may not throw.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Establishes the <code>result&lt;T&gt;</code> invariant:</p>
<div class="ulist">
<ul>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Value state</a>, initialize it with an object of type <code>T</code> or use the default constructor.</p>
</li>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Error state</a>, initialize it with an <a href="#error_id"><code>error_id</code></a> object.</p>
</li>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Error-capture state</a>, call <a href="#capture_result"><code>capture_result</code></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializing the <code>result&lt;T&gt;</code> in Value state may throw, depending on which constructor of <code>T</code> is invoked;</p>
</li>
<li>
<p>Copying a <code>result&lt;T&gt;</code> in Value state throws any exceptions thrown by the <code>T</code> copy constructor;</p>
</li>
<li>
<p>Other constructors do not throw.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A <code>result</code> that is in value state converts to <code>true</code> in boolean contexts. A <code>result</code> that is not in value state converts to <code>false</code> in boolean contexts.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::operator_eq"><code>operator=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt; &amp; result&lt;T&gt;::<span class="directive">operator</span>=( result &amp;&amp; ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt; &amp; result&lt;T&gt;::<span class="directive">operator</span>=( result <span class="directive">const</span> &amp; );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
  result&lt;T&gt; &amp; result&lt;T&gt;::<span class="directive">operator</span>=( result&lt;U&gt; &amp;&amp; ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">U</span>&gt;
  result&lt;T&gt; &amp; result&lt;T&gt;::<span class="directive">operator</span>=( result&lt;U&gt; <span class="directive">const</span> &amp; );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Destroys <code>*this</code>, then re-initializes it using the appropriate <code>result&lt;T&gt;</code> constructor. Basic exception-safety guarantee.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::operator_bool">Conversion to <code>bool</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result&lt;T&gt;::<span class="directive">operator</span> <span class="predefined-type">bool</span>() <span class="directive">const</span> <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>*this</code> is in <a href="#result">value state</a>, returns <code>true</code>, otherwise returns <code>false</code>. .</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::value"><code>value</code>/<code>operator*</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  T <span class="directive">const</span> &amp; result&lt;T&gt;::value() <span class="directive">const</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  T &amp; result&lt;T&gt;::value();

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  T <span class="directive">const</span> &amp; result&lt;T&gt;::<span class="directive">operator</span>*() <span class="directive">const</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  T &amp; result&lt;T&gt;::<span class="directive">operator</span>*();

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>If <code>*this</code> is in <a href="#result">value state</a>, returns a reference to the stored value, otherwise throws <code>leaf::<a href="#bad_result">bad_result</a></code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::error"><code>error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  error_id result&lt;T&gt;::error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This member function is designed for use in <code>return</code> statements in functions that return <code>result&lt;T&gt;</code> (or <code>leaf::<a href="#error_id">error_id</a></code>) to return an error to the caller.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> is in <a href="#result">value state</a>, returns <code><a href="#new_error">new_error</a>(std::forward&lt;E&gt;(e&#8230;&#8203;))</code>, which creates a new error (as opposed to forwarding an existing error);</p>
</li>
<li>
<p>If <code>*this</code> is in <a href="#result">error-capture state</a>, all captured E-objects are <a href="#propagation">propagated</a>, <code>*this</code> is converted to error state, and then</p>
</li>
<li>
<p>If <code>*this</code> is in <a href="#result">error state</a>, returns <code>err.<a href="#propagate">propagate</a>(std::forward&lt;E&gt;(e&#8230;&#8203;))</code>, where <code>err</code> is the <a href="#error_id"><code>error_id</code></a> stored in <code>*this</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="bad_result"><code>bad_result</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> bad_result: std::exception { };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This exception is thrown by <code><a href="#result::value">value</a>()</code>/<code><a href="#result::value">operator*</a>()</code> if they&#8217;re invoked for a <code>result</code> object that is in not in <a href="#result">value state</a>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="handle_some"><code>handle_some</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">TryBlock</span>, <span class="keyword">class</span><span class="error">.</span>.. Handler&gt;
  <span class="directive">decltype</span>(std::declval&lt;TryBlock&gt;()())
  handle_some( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When errors are communicated by <code><a href="#result">result</a>&lt;T&gt;</code>, the <code>handle_some</code> function template can be used to recognize and handle some errors, forwarding any unrecognized errors to the caller.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The <code>try_block</code> must be a function callable with no arguments that returns <code><a href="#result">result</a>&lt;T&gt;</code>;</p>
</li>
<li>
<p>All <code>handler&#8230;&#8203;</code> arguments must be functions that return the same type as the <code>try_block</code>, or types that convert implicitly to it (note: a <code>result&lt;T&gt;</code> object can be initialized by an <a href="#error_id"><code>error_id</code></a> object, regardless of <code>T</code>);</p>
</li>
<li>
<p>Each of the <code>handler&#8230;&#8203;</code> functions:</p>
<div class="ulist">
<ul>
<li>
<p>may take arguments of <a href="#e_objects">E-types</a>, either by value or by <code>const &amp;</code>, or as a <code>const *</code>;</p>
</li>
<li>
<p>may take arguments, either by value or by <code>const &amp;</code>, of the predicate type <code><a href="#match">match</a>&lt;E&gt;</code>, where <code>E</code> is an E-type;</p>
</li>
<li>
<p>may take an <a href="#error_info"><code>error_info</code></a> argument by <code>const &amp;</code>;</p>
</li>
<li>
<p>may take a <a href="#diagnostic_info"><code>diagnostic_info</code></a> argument by <code>const &amp;</code>;</p>
</li>
<li>
<p>may take a <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a> argument by <code>const &amp;</code>;</p>
</li>
<li>
<p>may not take any other types of arguments.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>When <code>handle_some</code> is invoked, LEAF reserves space inside of the <code>handle_some</code> scope (using automatic storage duration) to store the E-objects it would pass to the appropriate <code>handler</code> in case the <code>try_block</code> indicates an error.</p>
<div class="paragraph">
<p>The list of E-types that <code>handle_some</code> needs to store internally is deduced automatically, using the following steps, in order:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>A type list is deduced by concatenating all argument types of all <code>handler&#8230;&#8203;</code> functions;</p>
</li>
<li>
<p>References and cv-qualifiers are stripped from each type in the list;</p>
</li>
<li>
<p>The <a href="#error_info"><code>error_info</code></a>, <a href="#diagnostic_info"><code>diagnostic_info</code></a>, and <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a> types are removed from the list;</p>
</li>
<li>
<p>Any duplicate types are removed.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Next, <code>handle_some</code> calls the <code>try_block</code> function, which generally would call other functions as needed. When any function needs to report an error, it passes one or more E-objects to LEAF. For example, a function that returns a <code><a href="#result">result</a>&lt;T&gt;</code> can report an error with a call to <a href="#new_error"><code>new_error</code></a> in a <code>return</code> expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">if</span>( file-open-fails )
  <span class="keyword">return</span> leaf::new_error( error_code::file_open_error, e_file_name{fn} );</code></pre>
</div>
</div>
<div class="paragraph">
<p>As each E-type object is passed to LEAF, it is immediately moved to the <code>handle_some</code> (or <a href="#handle_all"><code>handle_all</code></a>, or <a href="#try_"><code>try_</code></a>) scope highest in the call stack that has available storage for that type, where it is uniquely associated with a specific <a href="#error_id"><code>error_id</code></a> (in this case, the value returned by <code>new_error</code>). Objects of E-types for which none of these scopes have available storage are discarded.</p>
</div>
</dd>
<dt class="hdlist1">Return Value: </dt>
<dd>
<p>If the <code><a href="#result">result</a>&lt;T&gt;</code> object <code>r</code> returned by the <code>try_block</code> function indicates success, <code>handle_some</code> returns <code>r</code>.</p>
<div class="paragraph">
<p>Otherwise, <code>handle_some</code> considers each of the <code>handler&#8230;&#8203;</code> functions, in order, until it finds one that matches the reported error. The first matching handler is invoked and the <code>result&lt;T&gt;</code> it returns is forwarded to the caller of <code>handle_some</code>; if no match is found, <code>handle_some</code> returns <code>r</code>.</p>
</div>
<div class="paragraph">
<p>If the value <code>handle_some</code> is returning indicates success, all stored E-objects are discarded. Otherwise, each stored E-object is moved to appropriate storage available in <code>handle_some</code> (or <a href="#handle_all"><code>handle_all</code></a>, or <a href="#try_"><code>try_</code></a>) scopes higher up the call stack (each moved object retains its unique association with its specific <code>error_id</code> value). E-objects for which such storage is not available are discarded.</p>
</div>
</dd>
<dt class="hdlist1">Handler Matching Procedure: </dt>
<dd>
<div class="paragraph">
<p>A <code>handler</code> matches the reported failure iff <code>handle_some</code> is able to produce values to pass as its arguments. As soon as it is determined that an argument value can not be produced, the current <code>handler</code> is dropped and the matching procedure continues with the next <code>handler</code>, if any.</p>
</div>
<div class="paragraph">
<p>If <code>err</code> is the specific <a href="#error_id"><code>error_id</code></a>  stored in the <code>result&lt;T&gt;</code> returned by the <code>try_block</code>, each argument value <code>a</code><sub>i</sub> to be passed to the <code>handler</code> currently under consideration is produced as follows:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If <code>a</code><sub>i</sub> is taken as <code>A</code><sub>i</sub> <code>const &amp;</code> or by value:</p>
<div class="ulist">
<ul>
<li>
<p>If an E-object of type <code>A</code><sub>i</sub>, associated with <code>err</code>, is currently stored in the <code>handle_some</code> scope, <code>a</code><sub>i</sub> is initialized with a reference to the stored object; otherwise the handler is dropped.</p>
</li>
<li>
<p>If <code>A</code><sub>i</sub> is of the predicate type <code><a href="#match">match</a>&lt;E&gt;</code>, if an object of type <code>E</code>, associated with <code>err</code>, is currently stored in the <code>handle_some</code> scope, <code>a</code><sub>i</sub> is initialized with a reference to the stored object; otherwise the handler is dropped. The handler is also dropped if the expression <code>a</code><sub>i</sub><code>()</code> evaluates to <code>false</code>.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="class">errors</span>
{
  ec1=<span class="integer">1</span>,
  ec2,
  ec3
};

....

<span class="keyword">return</span> leaf::handle_some(

  [ ]() -&gt; leaf::result&lt;<span class="directive">void</span>&gt;
  {
    ....
  },

  [ ]( leaf::match&lt;errors, errors::ec1&gt; ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    ....
  },

  [ ]( leaf::errors ec ) <i class="conum" data-value="2"></i><b>(2)</b>
  {
    ....
  } );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches if the error includes an object of type <code>errors</code> with value <code>ec1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This handler matches if the error includes an object of type <code>errors</code> regardless of its value.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>If <code>a</code><sub>i</sub> is of type <code>A</code><sub>i</sub> <code>const *</code>, <code>handle_some</code> is always able to produce it: if an E-object of type <code>A</code><sub>i</sub>, associated with <code>err</code>, is currently stored in the <code>handle_some</code> scope, <code>a</code><sub>i</sub> is initialized with the address of the stored object, otherwise it is initialized with <code>0</code>.</p>
</li>
<li>
<p>If <code>a</code><sub>i</sub> is of type <code>error_info const &amp;</code> or <code>diagnostic_info const &amp;</code> or <code>verbose_diagnostic_info const &amp;</code>,  <code>handle_some</code> is always able to produce it.</p>
</li>
<li>
<p>It is illegal to pass to <code>handle_some</code> a <code>handler</code> that takes any other argument types.</p>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Because <code>handle_some</code> can always produce arguments of type <code>error_info const &amp;</code>, <code>diagnostic_info const &amp;</code> and <code>verbose_diagnostic_info const &amp;</code>, a handler that only takes arguments of these types will match any error.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="handle_all"><code>handle_all</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">TryBlock</span>, <span class="keyword">class</span><span class="error">.</span>.. Handler&gt;
  <span class="keyword">typename</span> std::remove_reference&lt;<span class="directive">decltype</span>(std::declval&lt;TryBlock&gt;()().value())&gt;::type
  handle_all( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>handle_all</code> has the same requirements as <a href="#handle_some"><code>handle_some</code></a>, with the following change:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If <code>T</code> is the type returned by the <code>TryBlock</code>, all <code>handler&#8230;&#8203;</code> arguments must be functions that return <code>T</code> or a type that converts implicitly to <code>T</code> (note: <code>handle_some</code> handlers are required to return <code>result&lt;T&gt;</code>).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>And the following addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>At least one <code>handler</code> function (usually the last) must match any error. This is enforced at compile-time.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>The <code>handle_all</code> function works the same as <a href="#handle_some"><code>handle_some</code></a>, but because it is guaranteed to be able to match any error communicated by the <code>try_block</code> with a <code>handler</code>, it doesn&#8217;t need to return a <code>result&lt;T&gt;</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main()
{
  <span class="keyword">return</span> leaf::handle_all(
    [ ]() -&gt; leaf::result&lt;<span class="predefined-type">int</span>&gt;
    {
      <span class="comment">//do work, bail out returning leaf::error_id for any failure</span>
      ....

      std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Success!</span><span class="delimiter">&quot;</span></span>;
      <span class="keyword">return</span> <span class="integer">0</span>;
    },
    [ ]
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Error!</span><span class="delimiter">&quot;</span></span>;
      <span class="keyword">return</span> <span class="integer">1</span>;
    } );
}</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="match"><code>match</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">E</span>, <span class="keyword">typename</span> deduced-type&lt;E&gt;::type... V&gt;
  <span class="keyword">struct</span> match
  {
    <span class="directive">using</span> type = <span class="keyword">typename</span> deduced-type&lt;E&gt;::type;
    type <span class="directive">const</span> &amp; value;

    <span class="directive">explicit</span> match( E <span class="directive">const</span> &amp; e ) <span class="directive">noexcept</span>;

    <span class="predefined-type">bool</span> <span class="directive">operator</span>()() <span class="directive">const</span> <span class="directive">noexcept</span>;
  };

} }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>match</code> template is useful only as argument to a handler function passed to <a href="#handle_some"><code>handle_some</code></a> (or <code>handle_all</code> or <code>try_</code>).
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>E</code> defines an accessible data member <code>value</code>:</p>
<div class="ulist">
<ul>
<li>
<p>The type of the parameter pack <code>V&#8230;&#8203;</code> is deduced as <code>decltype(std::declval&lt;E&gt;().value)</code>;</p>
</li>
<li>
<p>The <code>match</code> constructor initializes the <code>value</code> reference with <code>e.value</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Otherwise:</p>
<div class="ulist">
<ul>
<li>
<p>The type of the parameter pack <code>V&#8230;&#8203;</code> is deduced as  <code>E</code>;</p>
</li>
<li>
<p>The <code>match</code> constructor initializes the <code>value</code> reference with <code>e</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>match</code> template is a predicate function type: <code>operator()</code> returns <code>true</code> iff the expression <code>value == V<sub>i</sub></code> is <code>true</code> for at least one <code>V</code><sub>i</sub> in <code>V&#8230;&#8203;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example 1:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> error_code { <span class="predefined-type">int</span> value; };

error_code e = {<span class="integer">42</span>};

match&lt;error_code, <span class="integer">1</span>&gt; m1(e);
assert(!m1());

match&lt;error_code, <span class="integer">42</span>&gt; m2(e);
assert(m2());

match&lt;error_code, <span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">42</span>, <span class="integer">7</span>&gt; m3(e);
assert(m3());

match&lt;error_code, <span class="integer">1</span>, <span class="integer">3</span>, -<span class="integer">42</span>&gt; m4(e);
assert(!m4());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">enum</span> error_code { e1=<span class="integer">1</span>, e2, e3 };

error_code e = e2;

match&lt;error_code, e1&gt; m1(e);
assert(!m1());

match&lt;error_code, e2&gt; m2(e);
assert(m2());

match&lt;error_code, e1, e2&gt; m3(e);
assert(m3());

match&lt;error_code, e1, e3&gt; m4(e);
assert(!m4());</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="capture_result"><code>capture_result</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture_result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E, <span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;unspecified_function_type&gt;&gt; capture_result( F &amp;&amp; f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>capture_result</code> function can be used to transport E-objects <a href="#propagation">propagated</a> when <code>f</code> is invoked in one thread, to a different thread which handles errors through <a href="#handle_some"><code>handle_some</code></a> or <a href="#handle_all"><code>handle_all</code></a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>F</code> must be a function type that returns a <code><a href="#result">result</a>&lt;T&gt;</code>;</p>
</li>
<li>
<p>Each of the <code>E&#8230;&#8203;</code> types must be an <a href="#e_objects">E-type</a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A function object <code>fw</code> of unspecified type, which acts as a wrapper for <code>f</code>, taking the same argument types and returning the same <code>result&lt;T&gt;</code> type.</p>
<div class="paragraph">
<p>When the caller invokes <code>fw</code> (presumably from a worker thread) with arguments <code>a&#8230;&#8203;</code> of types <code>A&#8230;&#8203;</code>:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Like <a href="#handle_some"><code>handle_some</code></a>, <code>fw</code> reserves storage in its scope for objects of the <code>E&#8230;&#8203;</code> types, then</p>
</li>
<li>
<p>invokes <code>f(std::forward&lt;A&gt;(a&#8230;&#8203;))</code>, which in general will call other functions as needed (any <a href="#propagation">propagated</a> objects of the <code>E&#8230;&#8203;</code> types are captured in the reserved storage).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>If the returned <code>result&lt;T&gt;</code> indicates success, it is forwarded to the caller; any E-objects stored in the <code>fw</code> scope are discarded.</p>
</div>
<div class="paragraph">
<p>Otherwise, all stored E-objects are moved to dynamically-allocated memory, which is used to initialize a <code>result&lt;T&gt;</code> object in <a href="#result">error-capture state</a>. This object is returned to the caller of <code>fw</code>.</p>
</div>
<div class="paragraph">
<p>The returned <code>result&lt;T&gt;</code> can safely cross thread boundaries (presumably sent back to the main thread). When it is returned from the <code>try_block</code> function passed to <a href="#handle_some"><code>handle_some</code></a> or <a href="#handle_all"><code>handle_all</code></a>, its contents are <a href="#propagation">propagated</a> (in that thread), and then error handling proceeds as usual.</p>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_ERROR"><code>LEAF_ERROR</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_ERROR(...) &lt;&lt;unspecified&gt;&gt;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p><code>LEAF_ERROR(e&#8230;&#8203;)</code> is equivalent to <code>leaf::<a href="#new_error">new_error</a>(e&#8230;&#8203;)</code>, except the current source location is automatically passed to <code>new_error</code> in a <code><a href="#common">e_source_location</a></code> object (in addition to all <code>e&#8230;&#8203;</code> objects).</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_AUTO"><code>LEAF_AUTO</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_AUTO(v,r)\
  <span class="directive">auto</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> = r;\
  <span class="keyword">if</span>( !_r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> )\
    <span class="keyword">return</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span>.error();\
  <span class="directive">auto</span> &amp; v = *_r_<span class="preprocessor">#</span><span class="preprocessor">#v</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>LEAF_AUTO</code> is useful when calling a function that returns <code>result&lt;T&gt;</code> (other than <code>result&lt;void&gt;</code>), if the desired behavior is to forward any errors to the caller verbatim.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="title">Compute two int values, return their sum as a float, using LEAF_AUTO:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="predefined-type">int</span>&gt; compute_value();

leaf::result&lt;<span class="predefined-type">float</span>&gt; add_values()
{
  LEAF_AUTO(v1, compute_value());
  LEAF_AUTO(v2, compute_value());
  <span class="keyword">return</span> v1 + v2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, we could write <code>add_value</code> without using <code>LEAF_AUTO</code>. This is equivalent:</p>
</div>
<div class="listingblock">
<div class="title">Compute two int values, return their sum as a float, without LEAF_AUTO:</div>
<div class="content">
<pre class="nowrap">leaf::result&lt;float&gt; add_values()
{
  auto v1 = compute_value();
  if( !v1 )
    return v1.error();

  auto v2 = compute_value();
  if( !v2 )
    return v2.error();

  return *v1 + *v2;
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_CHECK"><code>LEAF_CHECK</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_CHECK(r)\
  {\
    <span class="directive">auto</span> _r = r;\
    <span class="keyword">if</span>(!_r)\
      <span class="keyword">return</span> _r.error();\
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>LEAF_CHECK</code> is useful when calling a function that returns <code>result&lt;void&gt;</code>, if the desired behavior is to forward any errors to the caller verbatim.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="title">Try to send a message, then compute a value, report errors using LEAF_CHECK:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="directive">void</span>&gt; send_message( <span class="predefined-type">char</span> <span class="directive">const</span> * msg );

leaf::result&lt;<span class="predefined-type">int</span>&gt; compute_value();

leaf::result&lt;<span class="predefined-type">int</span>&gt; say_hello_and_compute_value()
{
  LEAF_CHECK(send_message(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello!</span><span class="delimiter">&quot;</span></span>));
  <span class="keyword">return</span> compute_value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent implementation without <code>LEAF_CHECK</code>:</p>
</div>
<div class="listingblock">
<div class="title">Try to send a message, then compute a value, report errors without LEAF_CHECK:</div>
<div class="content">
<pre class="nowrap">leaf::result&lt;float&gt; add_values()
{
  auto r = send_message("Hello!");
  if( !r )
    return r.error();

  return compute_value();
}</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exception_handling_api">Exception Handling API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="exception"><code>exception</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Ex</span>, <span class="keyword">class</span><span class="error">.</span>.. E&gt;
  &lt;&lt;unspecified&gt;&gt; exception( Ex &amp;&amp; ex, E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>Ex</code> must derive from <code>std::exception</code>.</p>
</li>
<li>
<p>For each <code>E</code><sub>i</sub> int <code>E&#8230;&#8203;</code>, <code><a href="#is_error_type">is_error_type</a>&lt;E<sub>i</sub>&gt;::value</code> is <code>true</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>An object of unspecified type which derives publicly from <code>Ex</code> <strong>and</strong> from class <a href="#error_id"><code>error_id</code></a> such that:</p>
<div class="ulist">
<ul>
<li>
<p>its <code>Ex</code> subobject is initialized by <code>std::forward&lt;Ex&gt;(ex)</code>;</p>
</li>
<li>
<p>its <code>error_id</code> subojbect is initialized by <code><a href="#new_error">new_error</a>(std::forward&lt;E&gt;(e)&#8230;&#8203;</code>).</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If thrown, the returned object can be caught as <code>Ex &amp;</code> or as <code>leaf::<a href="#error_id">error_id</a> &amp;</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To automatically capture <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code> with the returned object, use <a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a> instead of <code>leaf::exception</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="try_"><code>try_</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">TryBlock</span>, <span class="keyword">class</span><span class="error">.</span>.. Handler&gt;
  <span class="directive">decltype</span>(std::declval&lt;TryBlock&gt;()())
  try_( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>try_</code> has the same requirements as <a href="#handle_some"><code>handle_some</code></a>, with the following change:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>The <code>try_block</code> is not required to&#8201;&#8212;&#8201;and usually does not&#8201;&#8212;&#8201;return a <code>result&lt;T&gt;</code> (because, presumably, all failures are communicated by throwing exceptions).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>And the following addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each of the <code>handler&#8230;&#8203;</code> functions may take arguments, either by value or by <code>const &amp;</code>, of the predicate type <code><a href="#catch_">catch_</a>&lt;Ex&gt;</code>, where <code>Ex</code> is a type that derives from <code>std::exception</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p><code>try_</code> works similarly to <a href="#handle_some"><code>handle_some</code></a>&#8201;&#8212;&#8201;the difference is that <code>try_</code> catches exceptions thrown by the <code>try_block</code> function with a <code>catch(std::exception const &amp;)</code> or, if that fails, <code>catch(&#8230;&#8203;)</code>.</p>
</dd>
<dt class="hdlist1">Return Value: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If the <code>try_block</code> succeeds, <code>try_</code> forwards the return value to the caller;</p>
</li>
<li>
<p>Otherwise, it attempts to match the <a href="#error_id"><code>error_id</code></a> communicated with the caught exception with a <code>handler</code>. If that succeeds, <code>try_</code> forwards the return value from the matched <code>handler</code> to the caller;</p>
</li>
<li>
<p>Otherwise, <code>try_</code> re-throws the caught exception.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Handler Matching Procedure: </dt>
<dd>
<p>Because each E-object stored in the <code>try_</code> scope (see <a href="#handle_some"><code>handle_some</code></a>) is uniquely associated with a specific <a href="#error_id"><code>error_id</code></a>, <code>try_</code> needs to extract an <code>error_id</code> value from the caught exception in order to access any currently stored E-object (<code>handle_some</code> and <code>handle_all</code> do not have this challenge, since the <a href="#error_id"><code>error_id</code></a> they need is readily available in the <code><a href="#result">result</a>&lt;T&gt;</code> object communicating the failure).</p>
<div class="paragraph">
<p>When throwing, users are encouraged to pass the exception object through the <a href="#exception"><code>exception</code></a> function template&#8201;&#8212;&#8201;and <code>throw</code> the object it returns. This guarantees that the thrown exception transports a unique <code>error_id</code> value, just like <code>result&lt;T&gt;</code> does.</p>
</div>
<div class="paragraph">
<p>However, this isn&#8217;t possible when we don&#8217;t control the <code>throw</code> site, for example if the exception is thrown by a standard function. In this case, E-objects communicated to LEAF are associated with the <code>error_id</code> value returned by <a href="#next_error"><code>next_error</code></a>, which is a preview of sorts, of the <code>error_id</code> value that would be returned by the next call to <a href="#new_error"><code>new_error</code></a>.</p>
</div>
<div class="paragraph">
<p>Similarly, if the exception object caught by <code>try_</code> does not transports an <code>error_id</code> value, E-objects are looked up using the <code>error_id</code> value returned by <a href="#next_error"><code>next_error</code></a> just before <code>try_</code> goes through its <code>handler</code>-matching search. If imperfect, this approach provides the needed association.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="#get_error_id"><code>get_error_id</code></a> implements the procedure described above.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With the <code>error_id</code> value thus obtained, the <code>handler</code>-matching procedure works the same as in <a href="#handle_some"><code>handle_some</code></a>, with the following addition to the way each argument value <code>a</code><sub>i</sub> to be passed to the <code>handler</code> currently under consideration is produced:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>a</code><sub>i</sub> is taken as <code>A</code><sub>i</sub> <code>const &amp;</code> or by value:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>A</code><sub>i</sub> is of the predicate type <code><a href="#catch_">catch_</a>&lt;Ex&#8230;&#8203;&gt;</code>, <code>a</code><sub>i</sub> is initialized with the caught <code>std::exception const &amp;</code>. The handler is dropped if the expression <code>a</code><sub>i</sub><code>()</code> evaluates to <code>false</code>.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> exception1: std::exception { };
<span class="keyword">struct</span> exception2: std::exception { };
<span class="keyword">struct</span> exception3: std::exception { };

....

<span class="keyword">return</span> leaf::try_(

  [ ]() -&gt; leaf::result&lt;<span class="directive">void</span>&gt;
  {
    ....
  },

  [ ]( leaf::catch_&lt;exception1, exception2&gt; ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    ....
  },

  [ ]( leaf::error_info <span class="directive">const</span> &amp; info ) <i class="conum" data-value="2"></i><b>(2)</b>
  {
    ....
  } );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches if the exception caught by <code>try_</code> is either of type <code>exception1</code> or <code>exception2</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This handler matches any error. Use <code>info.<a href="#error_info">exception</a>()</code> to access any caught <code>std::exception</code> object.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="catch_"><code>catch_</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. Ex&gt;
  <span class="keyword">struct</span> catch_
  {
    std::exception <span class="directive">const</span> &amp; value;

    <span class="directive">explicit</span> catch_( std::exception <span class="directive">const</span> &amp; ex ) <span class="directive">noexcept</span>;

    <span class="predefined-type">bool</span> <span class="directive">operator</span>()() <span class="directive">const</span> <span class="directive">noexcept</span>;
  };

} }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>catch_</code> template is useful only as argument to a handler function passed to <a href="#try_"><code>try_</code></a>.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>The <code>catch_</code> constructor initializes the <code>value</code> reference with <code>ex</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>catch_</code> template is a predicate function type: <code>operator()</code> returns <code>true</code> iff for at least one of <code>Ex</code><sub>i</sub> in <code>Ex&#8230;&#8203;</code>, the expression <code>dynamic_cast&lt;Ex<sub>i</sub> const *&gt;(&amp;value) != 0</code> is <code>true</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> exception1: std::exception { };
<span class="keyword">struct</span> exception2: std::exception { };
<span class="keyword">struct</span> exception3: std::exception { };

exception2 x;

catch_&lt;exception1&gt; c1(x);
assert(!c1());

catch_&lt;exception2&gt; c2(x);
assert(c2());

catch_&lt;exception1,exception2&gt; c3(x);
assert(c3());

catch_&lt;exception1,exception3&gt; c4(x);
assert(!c4());</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="get_error_id"><code>get_error_id</code></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  error_id get_error_id( std::exception <span class="directive">const</span> &amp; ex ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If the dynamic type of <code>ex</code> derives from <a href="#error_id"><code>error_id</code></a>, returns the <code>error_id</code> slice of <code>ex</code>. Otherwise, returns the result of <a href="#next_error"><code>next_error</code></a>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please read the documentation for <a href="#try_"><code>try_</code></a> to understand why <code>get_error_id</code> is needed.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Whenever possible, pass exceptions you throw through the <a href="#exception"><code>exception</code></a> function template (or use <a href="#LEAF_THROW"><code>LEAF_THROW</code></a>). This ensures that the thrown exceptions derive from <a href="#error_id"><code>error_id</code></a>, which is always preferable to the <a href="#next_error"><code>next_error</code></a> hack.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="exception_to_result"><code>exception_to_result</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception_to_result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. Ex, <span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;deduced-type&gt;&gt; exception_to_result( F &amp;&amp; f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function can be used to catch exceptions from a lower-level library and convert them to <code><a href="#result">result</a>&lt;T&gt;</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>f</code> returns <code>T</code>, <code>exception_to_result</code> returns <code>result&lt;T&gt;</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Invokes <code>f</code> in a <code>try</code> block, catching each individual exception type <code>Ex</code>, by value, proceeding as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">catch</span>( Ex ex )
{
  <span class="keyword">return</span> leaf::new_error(std::move(ex));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A final catch-all is added, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">catch</span>(...)
{
  <span class="keyword">return</span> leaf::new_error(std::current_exception());
}</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>Catching by value slices each individual exception object.</p>
</li>
<li>
<p>The order of the types in the <code>Ex&#8230;&#8203;</code> list is significant.</p>
</li>
<li>
<p><code>std::current_exception()</code> likely allocates memory dynamically.</p>
</li>
<li>
<p>Handlers passed to <a href="#handle_some"><code>handle_some</code></a> / <a href="#handle_all"><code>handle_all</code></a> should take the converted-to-result exception objects by <code>const &amp;</code> (whereas, in case exceptions are handled directly by <a href="#try_"><code>try_</code></a> handlers, you would use <a href="#catch_"><code>catch_</code></a> instead).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> compute_answer_throws();

<span class="comment">//Call compute_answer, convert exceptions to result&lt;int&gt;</span>
leaf::result&lt;<span class="predefined-type">int</span>&gt; compute_answer()
{
  <span class="keyword">return</span> leaf::catch_exceptions&lt;
    ex_type1,
    ex_type2&gt;( compute_answer_throws() );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Later, the <code>ex_type1</code> and <code>ex_type2</code> exceptions can be processed by <a href="#handle_some"><code>handle_some</code></a> / <a href="#handle_all"><code>handle_all</code></a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">return</span> leaf::handle_some(

  [ ] -&gt; leaf::result&lt;<span class="directive">void</span>&gt;
  {
    LEAF_AUTO(answer, compute_answer());
    <span class="comment">//Use answer</span>
    ....
    <span class="keyword">return</span> { };
  },

  [ ]( ex_type1 <span class="directive">const</span> &amp; ex1 )
  {
    <span class="comment">//Handle ex_type1</span>
    ....
    <span class="keyword">return</span> { };
  },

  [ ]( ex_type2 <span class="directive">const</span> &amp; ex2 )
  {
    <span class="comment">//Handle ex_type2</span>
    ....
    <span class="keyword">return</span> { };
  },

  [ ]( std::exception_ptr <span class="directive">const</span> &amp; p )
  {
    <span class="comment">//Handle any other exception from compute_answer.</span>
    ....
    <span class="keyword">return</span> { };
  } );</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="capture_exception"><code>capture_exception</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture_exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E, <span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;unspecified_function_type&gt;&gt; capture_exception( F &amp;&amp; f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>capture_exception</code> function can be used to transport E-objects <a href="#propagation">propagated</a> when <code>f</code> is invoked in one thread, to a different thread which handles errors through <a href="#try_"><code>try_</code></a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>F</code> must be a function type;</p>
</li>
<li>
<p>Each of the <code>E&#8230;&#8203;</code> types must be an <a href="#e_objects">E-type</a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A function object <code>fw</code> of unspecified type, which acts as a wrapper for <code>f</code>, taking the same argument types and returning the same type as <code>f</code>.</p>
<div class="paragraph">
<p>When the caller invokes <code>fw</code> (presumably from a worker thread) with arguments <code>a&#8230;&#8203;</code> of types <code>A&#8230;&#8203;</code>:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Like <a href="#try_"><code>try_</code></a>, <code>fw</code> reserves storage in its scope for objects of the <code>E&#8230;&#8203;</code> types, then</p>
</li>
<li>
<p>invokes <code>f(std::forward&lt;A&gt;(a&#8230;&#8203;))</code>, which in general will call other functions as needed (any <a href="#propagation">propagated</a> objects of the <code>E&#8230;&#8203;</code> types are captured in the reserved storage);</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Except if <code>f</code> throws, any E-objects stored in the <code>fw</code> scope are discarded and the returned value is forwarded to the caller.</p>
</div>
<div class="paragraph">
<p>Otherwise, <code>fw</code> throws another exception object (of unspecified type) which holds all stored <code>E</code> objects and the original exception via <code>std::exception_ptr</code>.</p>
</div>
<div class="paragraph">
<p>If this new exception is thrown by the <code>try_block</code> function passed to <a href="#try_"><code>try_</code></a> (presumably after it was transported to the main thread), its contents are <a href="#propagation">propagated</a> (in that thread), and then error handling proceeds as usual.</p>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_EXCEPTION(...) &lt;&lt;unspecified&gt;&gt;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This is a variadic macro which forwards its arguments to the function template <a href="#exception"><code>exception</code></a>, in addition capturing <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code>, in a <code><a href="#common">e_source_location</a></code> object.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_THROW"><code>LEAF_THROW</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_THROW(...) <span class="keyword">throw</span> LEAF_EXCEPTION(__VA_ARGS__)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Throws the exception object returned by <a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="techniques">Programming Techniques</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="technique_preload">Preloading Error Objects</h3>
<div class="paragraph">
<p>Consider the following exception type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">class</span> <span class="class">file_read_error</span>: <span class="directive">public</span> std::exception
{
  std::<span class="predefined-type">string</span> file_name_;

  <span class="directive">public</span>:

  <span class="directive">explicit</span> file_read_error( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn ): file_name_(fn) { }

  std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; file_name() <span class="directive">const</span> <span class="directive">noexcept</span> { <span class="keyword">return</span> file_name_; }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A catch statement that handles <code>file_read_error</code> exceptions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">catch</span>( file_read_error &amp; e )
{
  std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Error reading </span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> &lt;&lt; e.file_name() &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, a function that may throw <code>file_read_error</code> exceptions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> read_file( FILE * f ) {
  ....
  size_t nr=fread(buf,<span class="integer">1</span>,count,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> file_read_error(???); <span class="comment">//File name not available here!</span>
  ....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a problem: the <code>catch</code> needs a file name, but at the point of the <code>throw</code> a file name is not available (only a <code>FILE</code> pointer is). In general, the error might be detected in a library which can not assume that a meaningful name is available for any <code>FILE</code> it reads, even if a program that uses the library could reasonably make the same assumption.</p>
</div>
<div class="paragraph">
<p>Using LEAF, a file name may be associated with any exception after it has been thrown, while anything available at the point of the <code>throw</code> (e.g. <code>errno</code>) may be passed directly to the <code>leaf::<a href="#exception">exception</a></code> function template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">class</span> <span class="class">file_open_error</span>: <span class="directive">public</span> std::exception { };
<span class="keyword">class</span> <span class="class">file_read_error</span>: <span class="directive">public</span> std::exception { };
<span class="keyword">struct</span> e_file_name { std::<span class="predefined-type">string</span> value; };
<span class="keyword">struct</span> e_errno { <span class="predefined-type">int</span> value; };

<span class="directive">void</span> read_file( FILE * f )
{
  ....
  size_t nr=fread( buf,<span class="integer">1</span>,count,f );
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> leaf::exception( file_read_error(), e_errno{errno} );
  ....
}

<span class="directive">void</span> process_file( <span class="predefined-type">char</span> <span class="directive">const</span> * name )
{
  <span class="directive">auto</span> propagate = leaf::preload( e_file_name{name} );

  <span class="keyword">if</span>( FILE * fp=fopen(name,<span class="string"><span class="delimiter">&quot;</span><span class="content">rt</span><span class="delimiter">&quot;</span></span>)) {
    std::shared_ptr&lt;FILE&gt; f(fp,fclose);
    ....
    read_file(fp); <span class="comment">//throws on error</span>
    ....
  }
  <span class="keyword">else</span>
    <span class="keyword">throw</span> leaf::exception(file_open_error());
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><code><a href="#exception">exception</a></code> | <a href="#preload"><code>preload</code></a></p>
</div>
<div class="paragraph">
<p>The key is the call to <code><a href="#preload">preload</a></code>: it ensures that the passed <code>e_file_name</code> will be associated with any exception that escapes <code>process_file</code>. This is fully automatic, and works regardless of whether the exception is thrown later in the same function, or by <code>read_file</code>, or by some third-party function we call.</p>
</div>
<div class="paragraph">
<p>Now, exceptions thrown by <code>process_file</code> may be handled like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::try_(

  [ ]
  {
    process_file(<span class="string"><span class="delimiter">&quot;</span><span class="content">example.txt</span><span class="delimiter">&quot;</span></span>);
  },

  [ ]( leaf::catch_&lt;file_open_error, file_read_error&gt;, e_file_name <span class="directive">const</span> &amp; fn, e_errno <span class="directive">const</span> &amp; errn )
  {
    std::cerr &lt;&lt;
      <span class="string"><span class="delimiter">&quot;</span><span class="content">I/O error!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl &lt;&lt;
      <span class="string"><span class="delimiter">&quot;</span><span class="content">File name: </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_"><code>try_</code></a> | <a href="#catch_"><code>catch_</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This technique works exactly the same way when errors are reported using <code>leaf::<a href="#result">result</a></code> rather than by throwing exceptions.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_defer">Capturing <code>errno</code> with <code>defer</code></h3>
<div class="paragraph">
<p>Consider the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> read_file(FILE * f) {
  ....
  size_t nr=fread(buf,<span class="integer">1</span>,count,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> leaf::exception( file_read_error(), e_errno{errno} );
  ....
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><code><a href="#exception">exception</a></code></p>
</div>
<div class="paragraph">
<p>It is pretty straight-forward, reporting <code>e_errno</code> as it detects a <code>ferror</code>. But what if it calls <code>fread</code> multiple times?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> read_file(FILE * f) {
  ....
  size_t nr1=fread(buf1,<span class="integer">1</span>,count1,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> leaf::exception( file_read_error(), e_errno{errno} );

  size_t nr2=fread(buf2,<span class="integer">1</span>,count2,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> leaf::exception( file_read_error(), e_errno{errno} );

  size_t nr3=fread(buf3,<span class="integer">1</span>,count3,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> leaf::exception( file_read_error(), e_errno{errno} );
  ....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ideally, associating <code>e_errno</code> with each exception should be automated. One way to achieve this is to not call <code>fread</code> directly, but wrap it in another function which checks for <code>ferror</code> and associates the <code>e_errno</code> with the exception it throws.</p>
</div>
<div class="paragraph">
<p><a href="#technique_preload">Preloading Errors</a> describes how to solve a very similar problem without a wrapper function, but that technique does not work for <code>e_errno</code> because <code><a href="#preload">preload</a></code> would capture <code>errno</code> before a <code>fread</code> call was attempted, at which point <code>errno</code> is probably <code>0</code>&#8201;&#8212;&#8201;or, worse, leftover from a previous I/O failure.</p>
</div>
<div class="paragraph">
<p>The solution is to use <code><a href="#defer">defer</a></code>, so we don&#8217;t have to remember to include <code>e_errno</code> with each exception; <code>errno</code> will be associated automatically with any exception that escapes <code>read_file</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> read_file(FILE * f) {

  <span class="directive">auto</span> propagate = leaf::defer([ ]{ <span class="keyword">return</span> e_errno{errno}; });

  ....
  size_t nr1=fread(buf1,<span class="integer">1</span>,count1,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> leaf::exception(file_read_error());

  size_t nr2=fread(buf2,<span class="integer">1</span>,count2,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> leaf::exception(file_read_error());

  size_t nr3=fread(buf3,<span class="integer">1</span>,count3,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> leaf::exception(file_read_error());
  ....
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#defer"><code>defer</code></a> | <code><a href="#exception">exception</a></code></p>
</div>
<div class="paragraph">
<p>This works similarly to <code>preload</code>, except that the capturing of the <code>errno</code> is deferred until the destructor of the <code>propagate</code> object is called, which calls the passed lambda function to obtain the <code>errno</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This technique works exactly the same way when errors are reported using <code>leaf::<a href="#result">result</a></code> rather than by throwing exceptions.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_augment_in_catch">Augmenting Exceptions in a <code>catch</code></h3>
<div class="paragraph">
<p>What makes <code><a href="#preload">preload</a></code> and <code><a href="#defer">defer</a></code> useful (see <a href="#technique_preload">Preloading Errors</a> and <a href="#technique_defer">Capturing <code>errno</code> with <code>defer</code></a>) is that they automatically include E-objects with any exception or error reported by a function.</p>
</div>
<div class="paragraph">
<p>But what if we need to include some E-object conditionally? When using exception handling, it would be nice to be able to do this in a <code>catch</code> statement which selectively augments passing exceptions.</p>
</div>
<div class="paragraph">
<p>LEAF supports the following approach, assuming all exceptions derive from <code>std::exception</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">try</span>
{
  ....
  function_that_throws();
  ....
}
<span class="keyword">catch</span>( std::exception <span class="directive">const</span> &amp; e )
{
  <span class="keyword">if</span>( condition )
    leaf::get_error_id(e).propagate( e_this{....}, e_that{....} );
  <span class="keyword">throw</span>;
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#get_error_id"><code>get_error_id</code></a> | <a href="#propagate"><code>propagate</code></a></p>
</div>
<div class="paragraph">
<p>The reason we need to use <a href="#get_error_id"><code>get_error_id</code></a> is that not all exception types derive from <code>leaf::<a href="#error_id">error_id</a></code>. If the caught exception has a <code>leaf::error_id</code> subobject, <code>get_error_id</code> will return that <code>leaf::error_id</code> slice.</p>
</div>
<div class="paragraph">
<p>But if the caught exception doesn&#8217;t  have a <code>leaf::error_id</code> subobject, <code>get_error_id</code> returns an unspecified <code>leaf::error_id</code>, which is temporarily associated with any and all current exceptions, until successfully handled by <a href="#try_"><code>try_</code></a>. While this association is imperfect (because it does not pertain to a specific exception object) it is the best that can be done in this case.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following approach is roughly equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">try</span>
{
  ....
  function_that_throws();
  ....
}
<span class="keyword">catch</span>( leaf::error_id err )
{
  <span class="keyword">if</span>( condition )
    err.propagate( e_this{....}, e_that{....} );
  <span class="keyword">throw</span>;
}
<span class="keyword">catch</span>( std::exception <span class="directive">const</span> &amp; e )
{
  <span class="keyword">if</span>( condition )
    leaf::next_error().propagate( e_this{....}, e_that{....} );
  <span class="keyword">throw</span>;
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#propagate"><code>propagate</code></a> | <a href="#next_error"><code>next_error</code></a></p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_disparate_error_types">Working with Disparate Error Types</h3>
<div class="paragraph">
<p>Because most libraries define their own mechanism for reporting errors, programmers often need to use multiple incompatible error-reporting interfaces in the same program. This led to the introduction of <code>boost::system::error_code</code> which later became <code>std::error_code</code>. Each <code>std::error_code</code> object is assigned an <code>error_category</code>. Libraries that communicate errors in terms of <code>std::error_code</code> define their own <code>error_category</code>. For libraries that do not, the user can "easily" define a custom <code>error_category</code> and still translate domain-specific error codes to <code>std::error_code</code>.</p>
</div>
<div class="paragraph">
<p>But let&#8217;s take a step back and consider <em>why</em> did we want to express every error in terms of the same static type, <code>std::error_code</code> in the first place? We need this translation because the C&#43;&#43; static type-checking system makes it difficult to write functions that may return error objects of the disparate static types used by different libraries. Outside of this limitation, it would be preferable to be able to write functions that can communicate errors in terms of arbitrary C&#43;&#43; types, as needed.</p>
</div>
<div class="paragraph">
<p>To drive this point further, consider the real world problem of mixing <code>boost::system::error_code</code> and <code>std::error_code</code> in the same program. In theory, both systems are designed to be able to express one error code in terms of the other. In practice, describing a <em>generic</em> system for error categorization in terms of another <em>generic</em> system for error categorization is not trivial.</p>
</div>
<div class="paragraph">
<p>Ideally, functions should be able to communicate different error types without having to translate between them, and C&#43;&#43; does offer a mechanism that does just that, it&#8217;s called exception handling. And it is not a coincidence that the attempt to bind C&#43;&#43; exception types with the interface of each function, A.K.A. exception specifications, was so problematic that it had to be abandoned (while I am an outspoken proponent of exception handling, I do acknowledge that in practice, often for good reasons, exception handling may not be available or permitted).</p>
</div>
<div class="paragraph">
<p>LEAF solves this problem without using exception handling: a scope that is able to handle either <code>std::error_code</code> or <code>boost::system::error_code</code> would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">return</span> handle_some(

  [ ]() -&gt; leaf::result&lt;T&gt;
  {
    <span class="comment">//Call operations which may report std::error_code and boost::system::error_code.</span>
    <span class="comment">//Return errors via result&lt;T&gt;.</span>
  },

  [ ]( std::error_code <span class="directive">const</span> &amp; e )
  {
    <span class="comment">//Handle std::error_code</span>
  },

  [ ]( boost::system::error_code <span class="directive">const</span> &amp; e )
  {
    <span class="comment">//Handle boost::system::error_code</span>
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#handle_some"><code>handle_some</code></a> |  <a href="#result"><code>result</code></a></p>
</div>
<div class="paragraph">
<p>And here is a function which, using LEAF, forwards either <code>std::error_code</code> or <code>boost::system::error_code</code> objects reported by lower level functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;T&gt; f()
{
  <span class="keyword">if</span>( std::error_code ec = g1() )
  {
    <span class="comment">//Success</span>
  }
  <span class="keyword">else</span>
    <span class="keyword">return</span> leaf::new_error(ec);

  <span class="keyword">if</span>( boost::system::error_code ec = g2() )
  {
    <span class="comment">//Success</span>
  }
  <span class="keyword">else</span>
    <span class="keyword">return</span> leaf::new_error(ec);
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_exception_to_result">Converting Exceptions to <code>result&lt;T&gt;</code></h3>
<div class="paragraph">
<p>It is sometimes necessary to catch exceptions thrown by lower-level library function, and report the error through different means, to a higher-level library which may not use exception handling.</p>
</div>
<div class="paragraph">
<p>Suppose we have an exception type hierarchy and a function <code>compute_answer_throws</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">class</span> <span class="class">error_base</span>: <span class="directive">public</span> <span class="directive">virtual</span> std::exception { };
<span class="keyword">class</span> <span class="class">error_a</span>: <span class="directive">public</span> <span class="directive">virtual</span> error_base { };
<span class="keyword">class</span> <span class="class">error_b</span>: <span class="directive">public</span> <span class="directive">virtual</span> error_base { };
<span class="keyword">class</span> <span class="class">error_c</span>: <span class="directive">public</span> <span class="directive">virtual</span> error_base { };

<span class="predefined-type">int</span> compute_answer_throws()
{
  <span class="keyword">switch</span>( rand()%<span class="integer">4</span> )
  {
    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="integer">42</span>;
    <span class="keyword">case</span> <span class="integer">1</span>: <span class="keyword">throw</span> error_a();
    <span class="keyword">case</span> <span class="integer">2</span>: <span class="keyword">throw</span> error_b();
    <span class="keyword">case</span> <span class="integer">3</span>: <span class="keyword">throw</span> error_c();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can write a simple wrapper using <a href="#exception_to_result"><code>exception_to_result</code></a>, which calls <code>compute_answer_throws</code> and switches to <code>result&lt;int&gt;</code> for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="predefined-type">int</span>&gt; compute_answer() <span class="directive">noexcept</span>
{
  <span class="keyword">return</span> leaf::exception_to_result&lt;error_a, error_b&gt;(
    [ ]
    {
      <span class="keyword">return</span> compute_answer_throws();
    } );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(As a demonstration, <code>compute_answer</code> specifically converts exceptions of type <code>error_a</code> or <code>error_b</code>, while it leaves <code>error_c</code> to be captured by <code>std::exception_ptr</code>).</p>
</div>
<div class="paragraph">
<p>Here is a simple function which prints successfully computed answers, forwarding any error (originally reported by throwing an exception) to its caller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="directive">void</span>&gt; print_answer() <span class="directive">noexcept</span>
{
  LEAF_AUTO(answer, compute_answer());
  std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Answer: </span><span class="delimiter">&quot;</span></span> &lt;&lt; answer &lt;&lt; std::endl;
  <span class="keyword">return</span> { };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, here is a scope that handles the errors (which used to be exception objects):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::handle_all(

  [ ]() -&gt; leaf::result&lt;<span class="directive">void</span>&gt;
  {
    LEAF_CHECK(print_answer());
    <span class="keyword">return</span> { };
  },

  [ ]( error_a <span class="directive">const</span> &amp; e )
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Error A!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
  },

  [ ]( error_b <span class="directive">const</span> &amp; e )
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Error B!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
  },

  [ ]
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown error!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
  } );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The complete program illustrating this technique is available <a href="https://github.com/zajo/leaf/blob/master/example/exception_to_result.cpp?ts=3">here</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_preload_in_c_callbacks">Using <code>next_error</code> in (Lua) C-callbacks</h3>
<div class="paragraph">
<p>Communicating information pertaining to a failure detected in a C callback is tricky, because C callbacks are limited to a specific static signature, which may not use C&#43;&#43; types.</p>
</div>
<div class="paragraph">
<p>LEAF makes this easy. As an example, we&#8217;ll write a program that uses Lua and reports a failure from a C&#43;&#43; function registered as a C callback, called from a Lua program. The failure will be propagated from C&#43;&#43;, through the Lua interpreter (written in C), back to the C&#43;&#43; function which called it.</p>
</div>
<div class="paragraph">
<p>C/C&#43;&#43; functions designed to be invoked from a Lua program must use the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c"><span class="predefined-type">int</span> do_work( lua_State * L );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Arguments are passed on the Lua stack (which is accessible through <code>L</code>). Results too are pushed onto the Lua stack.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s initialize the Lua interpreter and register <code>do_work</code> as a C callback, available for Lua programs to call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">std::shared_ptr&lt;lua_State&gt; init_lua_state() <span class="directive">noexcept</span>
{
  std::shared_ptr&lt;lua_State&gt; L(lua_open(),&amp;lua_close); <i class="conum" data-value="1"></i><b>(1)</b>

  lua_register( &amp;*L, <span class="string"><span class="delimiter">&quot;</span><span class="content">do_work</span><span class="delimiter">&quot;</span></span>, &amp;do_work ); <i class="conum" data-value="2"></i><b>(2)</b>

  luaL_dostring( &amp;*L, <span class="string"><span class="delimiter">&quot;</span></span><span class="error">\</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="error">\</span>n      function call_do_work()\
<span class="error">\</span>n          <span class="keyword">return</span> do_work()\
<span class="error">\</span>n      end<span class="string"><span class="delimiter">&quot;</span><span class="content"> );

  return L;
}</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a new <code>lua_State</code>. We&#8217;ll use <code>std::shared_ptr</code> for automatic cleanup.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Register the <code>do_work</code> C&#43;&#43; function as a C callback, under the global name <code>do_work</code>. With this, calls from Lua programs to <code>do_work</code> will land in the <code>do_work</code> C&#43;&#43; function.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Pass some Lua code as a <code>C</code> string literal to Lua. This creates a global Lua function called <code>call_do_work</code>, which we will later ask Lua to execute.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, let&#8217;s define our <code>enum</code> used to communicate <code>do_work</code> failures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">enum</span> do_work_error_code
{
  ec1=<span class="integer">1</span>,
  ec2
};

<span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> is_error_type&lt;do_work_error_code&gt;: std::true_type { };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_error_type"><code>is_error_type</code></a></p>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to define the <code>do_work</code> callback function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> do_work( lua_State * L ) <span class="directive">noexcept</span>
{
  <span class="predefined-type">bool</span> success=rand()%<span class="integer">2</span>; <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="keyword">if</span>( success )
  {
    lua_pushnumber(L,<span class="integer">42</span>); <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="keyword">return</span> <span class="integer">1</span>;
  }
  <span class="keyword">else</span>
  {
    leaf::next_error().propagate(ec1); <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="keyword">return</span> luaL_error(L,<span class="string"><span class="delimiter">&quot;</span><span class="content">do_work_error</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="4"></i><b>(4)</b>
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#next_error"><code>next_error</code></a> | <a href="#propagate"><code>propagate</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>"Sometimes" <code>do_work</code> fails.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In case of success, push the result on the Lua stack, return back to Lua.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Associate an <code>do_work_error_code</code> object with the <strong>next</strong> <code>leaf::error_id</code> object we will definitely return from the <code>call_lua</code> function&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>&#8230;&#8203;once control reaches it, after we tell the Lua interpreter to abort the program.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we&#8217;ll write the function that calls the Lua interpreter to execute the Lua function <code>call_do_work</code>, which in turn calls <code>do_work</code>. We&#8217;ll return <code><a href="#result">result</a>&lt;int&gt;</code>, so that our caller can get the answer in case of success, or an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="predefined-type">int</span>&gt; call_lua( lua_State * L )
{
  lua_getfield( L, LUA_GLOBALSINDEX, <span class="string"><span class="delimiter">&quot;</span><span class="content">call_do_work</span><span class="delimiter">&quot;</span></span> );
  <span class="keyword">if</span>( <span class="predefined-type">int</span> err=lua_pcall(L,<span class="integer">0</span>,<span class="integer">1</span>,<span class="integer">0</span>) ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    <span class="directive">auto</span> propagate = leaf::preload( e_lua_error_message{lua_tostring(L,<span class="integer">1</span>)} ); <i class="conum" data-value="2"></i><b>(2)</b>
    lua_pop(L,<span class="integer">1</span>);
    <span class="keyword">return</span> leaf::new_error( e_lua_pcall_error{err} );
  }
  <span class="keyword">else</span>
  {
    <span class="predefined-type">int</span> answer=lua_tonumber(L,-<span class="integer">1</span>); <i class="conum" data-value="3"></i><b>(3)</b>
    lua_pop(L,<span class="integer">1</span>);
    <span class="keyword">return</span> answer;
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#preload"><code>preload</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Ask the Lua interpreter to call the global Lua function <code>call_do_work</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Something went wrong with the call, so we&#8217;ll return a <a href="#new_error"><code>new_error</code></a>. If this is a <code>do_work</code> failure, the <code>do_work_error_code</code> object prepared in <code>do_work</code> will become associated with this <code>leaf::error_id</code>. If not, we will still need to communicate that the <code>lua_pcall</code> failed with an error code and an error message.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Success! Just return the int answer.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, here is the <code>main</code> function which exercises <code>call_lua</code>, each time handling any failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main() <span class="directive">noexcept</span>
{
  std::shared_ptr&lt;lua_State&gt; L=init_lua_state();

  <span class="keyword">for</span>( <span class="predefined-type">int</span> i=<span class="integer">0</span>; i!=<span class="integer">10</span>; ++i )
  {
    leaf::handle_all(

      [&amp;]() -&gt; leaf::result&lt;<span class="directive">void</span>&gt;
      {
        LEAF_AUTO(answer, call_lua(&amp;*L));
        std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">do_work succeeded, answer=</span><span class="delimiter">&quot;</span></span> &lt;&lt; answer &lt;&lt; <span class="char">'\n'</span>; <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> { };
      },

      [ ]( do_work_error_code e ) <i class="conum" data-value="2"></i><b>(2)</b>
      {
        std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Got do_work_error_code = </span><span class="delimiter">&quot;</span></span> &lt;&lt; e &lt;&lt;  <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
      },

      [ ]( e_lua_pcall_error <span class="directive">const</span> &amp; err, e_lua_error_message <span class="directive">const</span> &amp; msg ) <i class="conum" data-value="3"></i><b>(3)</b>
      {
        std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Got e_lua_pcall_error, Lua error code = </span><span class="delimiter">&quot;</span></span> &lt;&lt; err.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> &lt;&lt; msg.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
      },

      [ ]( leaf::error_info <span class="directive">const</span> &amp; unmatched )
      {
        std::cerr &lt;&lt;
          <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown failure detected</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl &lt;&lt;
          <span class="string"><span class="delimiter">&quot;</span><span class="content">Cryptic diagnostic information follows</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl &lt;&lt;
          unmatched;
      } );
  }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#handle_all"><code>handle_all</code></a> | <a href="#result"><code>result</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the call to <code>call_lua</code> succeeded, just print the answer.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Handle <code>do_work</code> failures.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Handle all other <code>lua_pcall</code> failures.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Follow this link to see the complete program: <a href="https://github.com/zajo/leaf/blob/master/example/lua_callback_result.cpp?ts=3">lua_callback_result.cpp</a>.</p>
</div>
<div class="paragraph">
<p>Remarkably, the Lua interpreter is C&#43;&#43; exception-safe, even though it is written in C. Here is the same program, this time using a C&#43;&#43; exception to report failures from <code>do_work</code>: <a href="https://github.com/zajo/leaf/blob/master/example/lua_callback_eh.cpp?ts=3">lua_callback_eh.cpp</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_transport">Transporting Error Objects Between Threads</h3>
<div class="paragraph">
<p>With LEAF, <a href="#e_objects">E-Objects</a> use automatic storage duration, stored inside the scope of <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> or <a href="#try_"><code>try_</code></a> functions. When using concurrency, we need a mechanism to detach E-objects from a worker thread and transport them to another thread where errors are handled.</p>
</div>
<div class="paragraph">
<p>LEAF offers two interfaces for this purpose, one using <code>result&lt;T&gt;</code>, and another designed for programs that use exception handling.</p>
</div>
<div class="sect3">
<h4 id="technique_transport-result">Using <code>result&lt;T&gt;</code></h4>
<div class="paragraph">
<p>Let&#8217;s assume we have a <code>task</code> which produces a result but could also fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;task_result&gt; task();</code></pre>
</div>
</div>
<div class="paragraph">
<p>To prepare the returned <code>result</code> to be sent across the thread boundary, when we launch the asynchronous task, we wrap it in а call to <a href="#capture_result"><code>capture_result</code></a>, specifying which E-types we want captured:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">std::future&lt;leaf::result&lt;task_result&gt;&gt; launch_task()
{
  <span class="keyword">return</span> std::async(
    std::launch::async,
    leaf::capture_result&lt;E1, E2, E3&gt;(&amp;task));
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#capture_result"><code>capture_result</code></a> | <a href="#result"><code>result</code></a></p>
</div>
<div class="paragraph">
<p>That&#8217;s it! Later when we <code>get</code> the <code>std::future</code>, we can process the returned <code>result&lt;task_result&gt;</code> as if it was generated locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="comment">//std::future&lt;leaf::result&lt;task_result&gt;&gt; fut;</span>
fut.wait();

<span class="keyword">return</span> leaf::handle_some(

  [&amp;]() -&gt; leaf::result&lt;<span class="directive">void</span>&gt;
  {
    LEAF_AUTO(r, fut.get());
    <span class="comment">//Success!</span>
    <span class="keyword">return</span> { }
  },

  [ ]( E1 e1, E2 e2 )
  {
    <span class="comment">//Deal with E1, E2</span>
    ....
    <span class="keyword">return</span> { };
  },

  [ ]( E3 e3 )
  {
    <span class="comment">//Deal with E3</span>
    ....
    <span class="keyword">return</span> { };
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#handle_some"><code>handle_some</code></a> | <a href="#result"><code>result</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see a complete example program: <a href="https://github.com/zajo/leaf/blob/master/example/capture_result.cpp?ts=3">capture_result.cpp</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="technique_transport-exceptions">Using Exception Handling</h4>
<div class="paragraph">
<p>Let&#8217;s assume we have a <code>task</code> which produces a result but could also throw:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">task_result task();</code></pre>
</div>
</div>
<div class="paragraph">
<p>To prepare exceptions thrown by the <code>task</code> function to be sent across the thread boundary, when we launch the asynchronous task, we wrap it in а call to <a href="#capture_exception"><code>capture_exception</code></a>, specifying which E-types we want captured:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">std::future&lt;task_result&gt; launch_task()
{
  <span class="keyword">return</span> std::async(
    std::launch::async,
    leaf::capture_exception&lt;E1, E2, E3&gt;(&amp;task));
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a></p>
</div>
<div class="paragraph">
<p>That&#8217;s it! Later when we <code>get</code> the <code>std::future</code>, we can catch exceptions as if they&#8217;re thrown locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="comment">//std::future&lt;task_result&gt; fut;</span>
fut.wait();

try_(

  [&amp;]
  {
    <span class="directive">auto</span> r = fut.get();
    <span class="comment">//Success!</span>
  },

  [ ]( E1 e1, E2 e2 )
  {
    <span class="comment">//Deal with E1, E2</span>
    ....
  },

  [ ]( E3 e3 )
  {
    <span class="comment">//Deal with E3</span>
    ....
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_"><code>try_</code></a> | <a href="#result"><code>result</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see a complete example program: <a href="https://github.com/zajo/leaf/blob/master/example/capture_eh.cpp?ts=3">capture_eh.cpp</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale">Design</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_rationale">Rationale</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Definition: </dt>
<dd>
<p>Objects that carry information about error conditions are called error objects. For example, objects of type <code>std::error_code</code> are error objects.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The following reasoning is independent of what mechanics are used to transport error objects, whether it is exception handling or anything else.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Definition: </dt>
<dd>
<p>Depending on their interaction with error objects, functions can be classified as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Error-initiating</strong>: functions that initiate error conditions by creating new error objects.</p>
</li>
<li>
<p><strong>Error-neutral</strong>: functions that forward to the caller error objects returned by functions they call.</p>
</li>
<li>
<p><strong>Error-handling</strong>: functions that dispose of error objects forwarded to them, recovering normal program operation.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A crucial observation is that <em>error-initiating</em> functions are typically low level functions that lack any context and can not determine, much less dictate, the correct program behavior in response to errors they initiate. Error conditions which (correctly) lead to termination in some programs may (correctly) be ignored in others; yet other programs may recover from them and resume normal operation.</p>
</div>
<div class="paragraph">
<p>Stronger: authors of <em>error-initiating</em> functions may not even reason about what information about the error is required to deal with it, by a specific <em>error-handling</em> function in a specific program domain, except to pass any relevant information which is naturally available to them.</p>
</div>
<div class="paragraph">
<p>The same reasoning applies to <em>error-neutral</em> functions, but in this case there is the additional problem that the errors they need to communicate, in general, are initiated by functions multiple levels removed from them in the call chain, functions which usually are&#8201;&#8212;&#8201;and should be treated as&#8201;&#8212;&#8201;implementation details. The <em>error-neutral</em> function should not be coupled with any error object type used by <em>error-initiating</em> functions, for the same reason it should not be coupled with any other aspect of their interface.</p>
</div>
<div class="paragraph">
<p>Finally, <em>error-handling</em> functions, by definition, have the full context they need to deal with at least some, if not all, failures. In this scope it is an absolute necessity that the author knows exactly what information must be communicated by lower level functions in order to recover from each error condition. Specifically, none of this necessary information can be treated as implementation details; here, the coupling which is to be avoided by <em>error-neutral</em> functions is unavoidable, in fact desirable.</p>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to define our</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Design goals: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><strong>Error-initiating</strong> functions should be able to communicate all information available to them that is relevant to the failure being reported.</p>
</li>
<li>
<p><strong>Error-neutral</strong> functions should not interfere or be coupled with error-related information that passes through them. They should be able to augment it with any additional information available to them that may be relevant to any error they forward to the caller.</p>
</li>
<li>
<p><strong>Error-handling</strong> functions should be able to access all the information communicated by <em>error-initiating</em> or <em>error-neutral</em> functions that is needed in their domain in order to deal with failures.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The difficulty in reaching these design goals is in that they seem to require that all error objects be allocated dynamically (the Boost Exception library meets these design goals at the cost of dynamic memory allocation).</p>
</div>
<div class="paragraph">
<p>As it turns out, dynamic memory allocation is not necessary due to the following</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Fact: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><strong>Error-handling</strong> functions already "know" which of the information <em>error-initiating</em> and <em>error-neutral</em> functions are <span class="underline">able</span> to communicate is <span class="underline">actually needed</span> in order to deal with failures in a particular program domain. Ideally, no resources should be <span class="line-through">used</span> wasted storing or communicating information which is not currently needed to handle errors, even if it is relevant to the failure.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The LEAF functions <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> and <a href="#try_"><code>try_</code></a> implement this idea. Users provide error-handling lambda functions which, naturally, take the arguments types they need. LEAF simply provides space needed to store these types, using automatic storage duration, before they are passed to a handler.</p>
</div>
<div class="paragraph">
<p>When this space is created, <code>thread_local</code> pointers of the required error types are set to point to the corresponding storage within the scope of <a href="#handle_some"><code>handle_some</code></a>, <a href="#handle_all"><code>handle_all</code></a> or <a href="#try_"><code>try_</code></a>. Later on, <em>error-initiating</em> or <em>error-neutral</em> functions wanting to communicate an error object of type <code>E</code> access the corresponding <code>thread_local</code> pointer to see if there is currently storage available for this type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the pointer is not null, storage is available and the object is moved into that storage, exactly once&#8201;&#8212;&#8201;regardless of how many levels of function calls must unwind before an appropriate <em>error-handling</em> function is reached.</p>
</li>
<li>
<p>If the pointer is null, storage is not available and the error object is discarded, since no error-handling function makes any use of it&#8201;&#8212;&#8201;saving resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This almost works, except we need to make sure that <em>error-handling</em> functions are protected from being passed stale error objects stored in an error-handling scope, left there from previous failures, which would be a serious logic error. To this end, each failure is assigned a unique <a href="#error_id"><code>error_id</code></a>, which is transported inside <code>leaf::<a href="#result">result</a></code> objects that communicate failures. Each of the <code>E&#8230;&#8203;</code> objects stored in error-handling scopes is assigned the same unique identifier, permanently associating it with a particular error.</p>
</div>
<div class="paragraph">
<p>Lastly, in <em>error-handling</em> functions it makes sense to be able to not only recognize individual error conditions, but match specific error-handling code with the complete set of error objects that is required in each case.</p>
</div>
<div class="paragraph">
<p>In terms of C&#43;&#43; exception handling, it would be nice to be able to say something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">try</span>
{
  <span class="directive">auto</span> r = process_file();

  <span class="comment">//Success, use r:</span>
  ....
}

<span class="keyword">catch</span>( file_read_error <span class="directive">const</span> &amp;, e_file_name <span class="directive">const</span> &amp; fn, e_errno <span class="directive">const</span> &amp; err )
{
  std::cerr &lt;&lt;
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not read </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; err &lt;&lt; std::endl;
}

<span class="keyword">catch</span>( file_read_error <span class="directive">const</span> &amp;, e_errno <span class="directive">const</span> &amp; err )
{
  std::cerr &lt;&lt;
    <span class="string"><span class="delimiter">&quot;</span><span class="content">File read error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; err &lt;&lt; std::endl;
}

<span class="keyword">catch</span>( file_read_error <span class="directive">const</span> &amp; )
{
  std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File read error!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is to say, it is desirable to be able to dispatch error handling based not only on the kind of failure being handled, but also based on the kind of E-objects available. Unfortunately this syntax is not possible and, even if it were, not all programs use exceptions to handle errors.</p>
</div>
<div class="paragraph">
<p>LEAF achieves the same effect using a slightly different syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::try_(

  [ ]
  {
    <span class="directive">auto</span> r = process_file(); <span class="comment">//Throws in case of failure, E-objects stored inside the try_ scope</span>

    <span class="comment">//Success, use r:</span>
    ....
  }

  [ ]( leaf::catch_&lt;file_read_error&gt;, e_file_name <span class="directive">const</span> &amp; fn, e_errno <span class="directive">const</span> &amp; err )
  {
    std::cerr &lt;&lt;
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not read </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; err &lt;&lt; std::endl;
  },

  [ ]( leaf::catch_&lt;file_read_error&gt;, e_errno <span class="directive">const</span> &amp; err )
  {
    std::cerr &lt;&lt;
      <span class="string"><span class="delimiter">&quot;</span><span class="content">File read error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; err &lt;&lt; std::endl;
  },

  [ ]( leaf::catch_&lt;file_read_error&gt; )
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File read error!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_"><code>try_</code></a> | <a href="#catch_"><code>catch_</code></a></p>
</div>
<div class="paragraph">
<p>Of course LEAF works without exception handling as well. Below is the same snippet, written using <code><a href="#result">result</a>&lt;T&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">return</span> leaf::handle_some(

  [ ]() -&gt; leaf::result&lt;<span class="directive">void</span>&gt;
  {
    LEAF_AUTO(r, process_file()); <span class="comment">//In case of errors, E-objects are stored inside the handle_some scope</span>

    <span class="comment">//Success, use r:</span>
    ....

    <span class="keyword">return</span> { };
  }

  [ ]( leaf::match&lt;error_enum, file_read_error&gt;, e_file_name <span class="directive">const</span> &amp; fn, e_errno <span class="directive">const</span> &amp; err )
  {
    std::cerr &lt;&lt;
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not read </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; err &lt;&lt; std::endl;
  },

  [ ]( leaf::match&lt;error_enum, file_read_error&gt;, e_errno <span class="directive">const</span> &amp; err )
  {
    std::cerr &lt;&lt;
      <span class="string"><span class="delimiter">&quot;</span><span class="content">File read error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; err &lt;&lt; std::endl;
  },

  [ ]( leaf::match&lt;error_enum, file_read_error&gt; )
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File read error!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#handle_some"><code>handle_some</code></a> | <a href="#match"><code>match</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please post questions and feedback on the Boost Developers Mailing List (LEAF is not part of Boost).
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="exception_specifications">Critique 1: LEAF Does Not Enforce Correct Error Handling at Compile Time</h3>
<div class="paragraph">
<p>A common critique of the LEAF design is that it does not statically enforce correct error handling. One specific idea I&#8217;ve heard from multiple sources is to add <code>E&#8230;&#8203;</code> parameter pack to <code>result&lt;T&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The idea is to be able to write something along these lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">result&lt;T, E1, E2, E3&gt; f() <span class="directive">noexcept</span>; <i class="conum" data-value="1"></i><b>(1)</b>

result&lt;T, E1, E3&gt; g() <span class="directive">noexcept</span> <i class="conum" data-value="2"></i><b>(2)</b>
{
  <span class="keyword">if</span>( result&lt;T, E1, E2, E3&gt; r = f() )
  {
    <span class="keyword">return</span> r; <span class="comment">//Success, return the T</span>
  }
  <span class="keyword">else</span>
  {
    <span class="keyword">return</span> r.handle_error&lt;E2&gt;( [ ] ( .... ) <i class="conum" data-value="3"></i><b>(3)</b>
      {
        ....
      } );
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>f</code> may only return errors of type <code>E1</code>, <code>E2</code>, <code>E3</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>g</code> narrows that to only <code>E1</code> and <code>E3</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Because <code>g</code> may only return errors of type <code>E1</code> and <code>E3</code>, it uses <code>handle_error</code> to deal with <code>E2</code>. In case <code>r</code> contains <code>E1</code> or <code>E3</code>, <code>handle_error</code> simply returns <code>r</code>, narrowing the error type parameter pack from <code>E1, E2, E3</code> down to <code>E1, E3</code>. If <code>r</code> contains an <code>E2</code>, <code>handle_error</code> calls the supplied lambda, which is required to return one of <code>E1</code>, <code>E3</code> (or a valid <code>T</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The motivation here is to help avoid bugs in functions that handle errors that pop out of <code>g</code>: as long as the programmer deals with <code>E1</code> and <code>E3</code>, he can rest assured that no error is left unhandled.</p>
</div>
<div class="paragraph">
<p>Congratulations, we&#8217;ve just discovered exception specifications. The difference is that exception specifications, before being removed from C&#43;&#43;, were enforced dynamically, while this idea is equivalent to statically-enforced exception specifications, like they are in Java.</p>
</div>
<div class="paragraph">
<p>Why not statically enforce exception specifications?</p>
</div>
<div class="quoteblock">
<blockquote>
The short answer is that nobody knows how to fix exception specifications in any language, because the dynamic enforcement C++ chose has only different (not greater or fewer) problems than the static enforcement Java chose. &#8230;&#8203; When you go down the Java path, people love exception specifications until they find themselves all too often encouraged, or even forced, to add <code>throws Exception</code>, which immediately renders the exception specification entirely meaningless. (Example: Imagine writing a Java generic that manipulates an arbitrary type <code>T</code>).<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>
</blockquote>
<div class="attribution">
&#8212; Herb Sutter
</div>
</div>
<div class="paragraph">
<p>While it is possible to turn every  error <strong>type</strong> into, for example, a <code>std::error_code</code> <strong>object</strong>, this would eliminate the static type checking benefits we sought. Worse, the excessive coupling between the signatures of <a href="#rationale">error-neutral</a> functions (read: most functions in a program) and the error types they need to forward up the call stack interferes with the lossless propagation of errors throughout the program.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Conclusion: </dt>
<dd>
<p>Attempts to harness the C&#43;&#43; static type checking system to help enforce correct error handling based on the types of errors a function may return require dynamic error types in generic contexts.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="translation">Critique 2: LEAF Does Not Facilitate Mapping Between Disparate Error Codes</h3>
<div class="paragraph">
<p>Most C&#43;&#43; programs use multiple C and C&#43;&#43; libraries, and each library may provide its own system of error codes. But because it is difficult to define static interfaces that can communicate arbitrary error code types, a popular idea is to map each library-specific error code to a common program-wide enum.</p>
</div>
<div class="paragraph">
<p>For example, if we have&#8201;&#8212;&#8201;</p>
</div>
<table class="tableblock frame-none grid-none stripes-none" style="width: 1%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> lib_a
{
  <span class="keyword">enum</span> error
  {
    ok,
    ec1,
    ec2,
    ....
  };
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> lib_b
{
  <span class="keyword">enum</span> error
  {
    ok,
    ec1,
    ec2,
    ....
  };
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;we could define:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> program
{
  <span class="keyword">enum</span> error
  {
    ok,
    lib_a_ec1,
    lib_a_ec2,
    ....
    lib_b_ec1,
    lib_b_ec2,
    ....
  };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An error-handling library could provide a conversion API that uses the C&#43;&#43; static type system to automate the mapping between the different error enums. For example, it may define a class template <code>result&lt;T,E&gt;</code> with value-or-error variant semantics, so that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lib_a</code> errors are transported in <code>result&lt;T,lib_a::error&gt;</code>,</p>
</li>
<li>
<p><code>lib_b</code> errors are transported in <code>result&lt;T,lib_b::error&gt;</code>,</p>
</li>
<li>
<p>then both are automatically mapped to <code>result&lt;T,program::error&gt;</code> once control reaches the appropriate scope.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are several problems with this idea:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is prone to errors, both during the initial implementation as well as under maintenance.</p>
</li>
<li>
<p>It does not compose well. For example, if <code>lib_a</code> and <code>lib_b</code> use <code>lib_c</code>, errors that originate in <code>lib_c</code> would be obfuscated by the different APIs exposed by each of the higher level libraries.</p>
</li>
<li>
<p>It presumes that all errors in the program can be specified by exactly one error code, which is false.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider a program that attempts to read a configuration file from three different locations: in case all of the attempts fail, it should communicate each of the failures. In theory <code>result&lt;T,E&gt;</code> handles this case well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> attempted_location
{
  std::<span class="predefined-type">string</span> path;
  error ec;
};

<span class="keyword">struct</span> config_error
{
  attempted_location current_dir, user_dir, app_dir;
};

result&lt;config,config_error&gt; read_config();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This looks nice, until we realize what the <code>config_error</code> type means for the automatic mapping API we wanted to define: an <code>enum</code> can not represent a <code>struct</code>. It is a fact that we can not assume that all error conditions can be fully specified by an <code>enum</code>; an error handling library must be able to transport arbitrary static types efficiently.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Conclusion: </dt>
<dd>
<p>Transporting error objects in return values works great if the failure is handled by the immediate caller of the function that reports it, but most error objects must be communicated across multiple layers of function calls and APIs, which leads to excessive physical coupling between these interfaces.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While the <code>leaf::<a href="#result">result</a>&lt;T&gt;</code> class template does have value-or-error semantics, it does not carry the actual error objects. Instead, they are forwarded directly to the appropriate error-handling scope and their types do not participate in function signatures.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_alternatives_to_leaf">Alternatives to LEAF</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/boost-exception.html">Boost Exception</a></p>
</li>
<li>
<p><a href="https://ned14.github.io/outcome">Boost Outcome</a></p>
</li>
<li>
<p><a href="https://github.com/pdimov/variant2">variant2 / <code>expected&lt;T,E&#8230;&#8203;&gt;</code></a></p>
</li>
<li>
<p><a href="https://zajo.github.io/boost-noexcept">Noexcept</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below we offer a comparison of LEAF to Boost Exception and to Boost Outcome.</p>
</div>
<div class="sect2">
<h3 id="boost_exception">Comparison to Boost Exception</h3>
<div class="paragraph">
<p>While LEAF can be used without exception handling, in the use case when errors are communicated by throwing exceptions, it can be viewed as a better, more efficient alternative to Boost Exception. LEAF has the following advantages over Boost Exception:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LEAF does not allocate memory dynamically;</p>
</li>
<li>
<p>LEAF does not waste system resources communicating error objects not used by specific error handling functions;</p>
</li>
<li>
<p>LEAF does not store the error objects in the exception object, and therefore it is able to augment exceptions thrown by external libraries (Boost Exception can only augment exceptions of types that derive from <code>boost::exception</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following tables outline the differences between the two libraries which should be considered when code that uses Boost Exception is refactored to use LEAF instead:</p>
</div>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 1. Defining a custom type for transporting values of type T</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">typedef</span> error_info&lt;<span class="keyword">struct</span> my_info_,T&gt; my_info;</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> my_info { T value; };</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 2. Passing arbitrary info at the point of the throw</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">throw</span> my_exception() &lt;&lt;
  my_info(x) &lt;&lt;
  my_info(y);</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_operator_shl.html"><code>operator&lt;&lt;</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">throw</span> leaf::exception( my_exception(),
  my_info{x},
  my_info{y} );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#exception"><code>exception</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 3. Augmenting exceptions in exception-neutral contexts</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">try</span>
{
  f();
}
<span class="keyword">catch</span>( boost::exception &amp; e )
{
  e &lt;&lt; my_info(x);
  <span class="keyword">throw</span>;
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception.html"><code>boost::exception</code></a> | <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_operator_shl.html"><code>operator&lt;&lt;</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">auto</span> propagate = leaf::preload( my_info{x} );

f();</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#preload"><code>preload</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 4. Obtaining arbitrary info at the point of the catch</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">try</span>
{
  f();
}
<span class="keyword">catch</span>( my_exception &amp; e )
{
  <span class="keyword">if</span>( T * v = get_error_info&lt;my_info&gt;(e) )
  {
    <span class="comment">//my_info is available in e.</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/get_error_info.html"><code>boost::get_error_info</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::try_(
  [ ]
  {
    f();
  }
  [ ]( leaf::catch_&lt;my_exception&gt;, my_info <span class="directive">const</span> &amp; x )
  {
    <span class="comment">//my_info is available with e.</span>
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_"><code>try_</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 5. Propagation of <a href="#e_objects">E-Objects</a></caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>All supplied <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a> objects are allocated dynamically, stored in the <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception.html"><code>boost::exception</code></a> object, and propagated.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>User-defined error objects are stored statically in the scope of <a href="#try_"><code>try_</code></a>, but only if their types are used to handle errors; otherwise they are discarded.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 6. Transporting of <a href="#e_objects">E-Objects</a> across thread boundaries</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_ptr.html"><code>boost::exception_ptr</code></a> automatically captures <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a> objects stored in a <code>boost::exception</code> and can transport them across thread boundaries.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Transporting error objects across thread boundaries requires the use of <a href="#capture_exception"><code>capture_exception</code></a>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 7. Printing of error objects in automatically-generated diagnostic information messages</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boost::error_info</code> types may define conversion to <code>std::string</code> by providing <code>to_string</code> overloads <strong>or</strong> by overloading <code>operator&lt;&lt;</code> for <code>std::ostream</code>.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>LEAF does not use <code>to_string</code>. Error types may define <code>operator&lt;&lt;</code> overloads for <code>std::ostream</code>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The fact that Boost Exception stores all supplied <code>boost::error_info</code> objects&#8201;&#8212;&#8201;while LEAF discards them if they aren&#8217;t needed&#8201;&#8212;&#8201;affects the completeness of the message we get when we print <code>leaf::<a href="#diagnostic_info">diagnostic_info</a></code> objects, compared to the string returned by <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/diagnostic_information.html"><code>boost::diagnostic_information</code></a>.</p>
</div>
<div class="paragraph">
<p>If the user requires a complete diagnostic message, the solution is to use <code>leaf::<a href="#verbose_diagnostic_info">verbose_diagnostic_info</a></code>. In this case, before unused error objects are discarded by LEAF, they are converted to string and captured. Note that this allocates memory dynamically.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="boost_outcome">Comparison to Boost Outcome</h3>
<div class="sect3">
<h4 id="_design_differences">Design Differences</h4>
<div class="paragraph">
<p>Like LEAF, the <a href="https://ned14.github.io/outcome">Boost Outcome</a> library is designed to work in low latency environments. It provides two class templates, <code>result&lt;&gt;</code> and <code>outcome&lt;&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>result&lt;T,EC,NVP&gt;</code> can be used as the return type in <code>noexcept</code> functions which may fail, where <code>T</code> specifies the type of the return value in case of success, while <code>EC</code> is an "error code" type. Semantically, <code>result&lt;T,EC&gt;</code> is similar to <code>std::variant&lt;T,EC&gt;</code>. Naturally, <code>EC</code> defaults to <code>std::error_code</code>.</p>
</li>
<li>
<p><code>outcome&lt;T,EC,EP,NVP&gt;</code> is similar to <code>result&lt;&gt;</code>, but in case of failure, in addition to the "error code" type <code>EC</code> it can hold a "pointer" object of type <code>EP</code>, which defaults to <code>std::exception_ptr</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>NVP</code> is a policy type used to customize the behavior of <code>.value()</code> when the <code>result&lt;&gt;</code> or the <code>outcome&lt;&gt;</code> object contains an error.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The idea is to use <code>result&lt;&gt;</code> to communicate failures which can be fully specified by an "error code", and <code>outcome&lt;&gt;</code> to communicate failures that require additional information.</p>
</div>
<div class="paragraph">
<p>Another way to describe this design is that <code>result&lt;&gt;</code> is used when it suffices to return an error object of some static type <code>EC</code>, while <code>outcome&lt;&gt;</code> can also transport a polymorphic error object, using the pointer type <code>EP</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the default configuration of <code>outcome&lt;T&gt;</code> the additional information&#8201;&#8212;&#8201;or the additional polymorphic object&#8201;&#8212;&#8201;is an exception object held by <code>std::exception_ptr</code>. This targets the use case when an exception thrown by a lower-level library function needs to be transported through some intermediate contexts that are not exception-safe, to a higher-level context able to handle it. LEAF supports this case more efficiently, see <a href="#exception_to_result"><code>exception_to_result</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similar reasoning drives the design of LEAF as well. The difference is that while both libraries recognize the need to transport "something else" in addition to an "error code", LEAF provides an efficient solution to this problem, while Outcome shifts this burden to the user.</p>
</div>
<div class="paragraph">
<p>The <code>leaf::result&lt;&gt;</code> template deletes both <code>EC</code> and <code>EP</code>, which decouples it from the type of the error objects that are transported in case of a failure. This enables lower-level functions to freely communicate anything and everything they "know" about the failure: error code, even multiple error codes, file names, request IDs, etc. At the same time, the higher-level error-handling functions control which of this information is needed in a specific client program and which is not. This is ideal, because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authors of lower-level library functions lack context to determine which of the information that is both relevant to the error <em>and</em> naturally available to them needs to be communicated in order for a particular client program to recover from that error;</p>
</li>
<li>
<p>Authors of higher-level error-handling functions easily and confidently make this determination, which they communicate naturally to LEAF, by simply writing the necessary error handlers. LEAF automatically and efficiently transports the needed E-objects while discarding the ones handlers don&#8217;t use, saving resources.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The LEAF examples include an adaptation of the program from the <a href="https://ned14.github.io/outcome/tutorial/result/">Boost Outcome <code>result&lt;&gt;</code> tutorial</a>. You can <a href="https://github.com/zajo/leaf/blob/master/example/print_half.cpp?ts=3">view it on GitHub</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_the_interoperability_problem">The Interoperability Problem</h4>
<div class="paragraph">
<p>The Boost Outcome documentation discusses the important problem of bringing together multiple libraries&#8201;&#8212;&#8201;each using its own error reporting mechanism&#8201;&#8212;&#8201;and incorporating them in a robust error handling infrastructure in a client program.</p>
</div>
<div class="paragraph">
<p>Users are advised that whenever possible they should use a common error handling system throughout their entire codebase, but because this is not practical, both the <code>result&lt;&gt;</code> and the <code>outcome&lt;&gt;</code> templates can carry user-defined "payloads".</p>
</div>
<div class="paragraph">
<p>The following analysis is from the Boost Outcome documentation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>If library A uses <code>result&lt;T, libraryA::failure_info&gt;</code>, and library B uses <code>result&lt;T, libraryB::error_info&gt;</code> and so on, there becomes a problem for the application writer who is bringing in these third party dependencies and tying them together into an application. As a general rule, each third party library author will not have built in explicit interoperation support for unknown other third party libraries. The problem therefore lands with the application writer.</p>
</div>
<div class="paragraph">
<p>The application writer has one of three choices:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the application, the form of result used is <code>result&lt;T, std::variant&lt;E1, E2, &#8230;&#8203;&gt;&gt;</code> where <code>E1, E2 …</code> are the failure types for every third party library in use in the application. This has the advantage of preserving the original information exactly, but comes with a certain amount of use inconvenience and maybe excessive coupling between high level layers and implementation detail.</p>
</li>
<li>
<p>One can translate/map the third party’s failure type into the application’s failure type at the point of the failure exiting the third party library and entering the application. One might do this, say, with a C preprocessor macro wrapping every invocation of the third party API from the application. This approach may lose the original failure detail, or mis-map under certain circumstances if the mapping between the two systems is not one-one.</p>
</li>
<li>
<p>One can type erase the third party’s failure type into some application failure type, which can later be reconstituted if necessary. This is the cleanest solution with the least coupling issues and no problems with mis-mapping, but it almost certainly requires the use of <code>malloc</code> which the previous two did not.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>The analysis above is clear and precise, but LEAF and Boost Outcome tackle the interoperability problem differently:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Boost Outcome design asserts that the "cleanest" solution based on type-erasure is suboptimal ("almost certainly requires the use of <code>malloc</code>"), and instead provides a system for injecting custom converters into the <code>outcome::convert</code> namespace, used to translate between library-specific and program-wide error types.</p>
</li>
<li>
<p>The LEAF design asserts that coupling the signatures of <a href="#rationale">error-neutral</a> functions with the static types of the error objects they need to forward to the caller <a href="#translation">does not scale</a>, and instead transports error objects directly to error-handling scopes where they are stored statically (without the use of <code>malloc</code>).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distribution">Distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The source code is <a href="https://github.com/zajo/leaf">available</a> on GitHub.</p>
</div>
<div class="paragraph">
<p>Copyright (c) 2018 Emil Dotchevski. Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
<div class="paragraph">
<p>Please post questions and feedback on the Boost Developers Mailing List (LEAF is not part of Boost).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="portability">Portability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF requires a C&#43;&#43;11 compiler.</p>
</div>
<div class="paragraph">
<p>See unit test matrix at <a href="https://travis-ci.org/zajo/leaf">Travis-CI</a>. It has also been tested with Microsoft Visual Studio 2015 and 2017 (please install the latest patches from Microsoft).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="building">Building</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF is a header-only library and it requires no building. It does not depend on Boost or on any other library.</p>
</div>
<div class="paragraph">
<p>The unit tests can be run with Boost Build or with <a href="https://mesonbuild.com">Meson Build</a>. To run the unit tests:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If using Boost Build:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Clone LEAF under your <code>boost/libs</code> directory.</p>
</li>
<li>
<p>Execute:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="sh">cd leaf/test
../../../b2</code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>If using Meson Build:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Clone LEAF into any local directory.</p>
</li>
<li>
<p>Execute:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="sh">cd leaf
meson bld/debug
cd bld/debug
meson test</code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_acknowledgements">Acknowledgements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Special thanks to Peter Dimov.</p>
</div>
<div class="paragraph">
<p>Ivo Belchev, Sean Palmer, Jason King, Vinnie Falco, Glen Fernandes, Nir Friedman&#8201;&#8212;&#8201;thanks for the valuable feedback.</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Except when error objects are transported between threads, see <a href="#capture_result"><code>capture_result</code></a>/<a href="#capture_exception"><code>capture_exception</code></a>.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. <a href="https://herbsutter.com/2007/01/24/questions-about-exception-specifications/" class="bare">https://herbsutter.com/2007/01/24/questions-about-exception-specifications/</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>